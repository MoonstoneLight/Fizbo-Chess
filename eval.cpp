// evaluation function
#include "chess.h"
#include <intrin.h>
#include <math.h>
#include "coeffs.h"

UINT64 *eh; // eval hash pointer
short int *mh; // material table pointer
int endgame_weight_all_i[105]={1024,1024,1024,1024,1024,1024,1024,1024,1024,1024,1024,1024,1001,978,956,933,910,887,865,842,819,796,774,751,728,705,683,660,637,614,592,569,546,523,501,478,455,432,410,387,364,341,319,296,273,250,228,205,182,159,137,114,91,68,46,23,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}; // 0 to 1024, to be right-shifted by 10 bits

const unsigned int mat_key_mult[]={2916,26244, 1, 3, 9,27,81,243,729,1458,0, 0};
//							        wP,   bP, wN,bN,wB,bB,wR, bR, wQ, bQ, wK,bK

unsigned short int *ind1;
//static short int *mh2;
void init_material(void){// init material table
	unsigned int i;
	int wN,bN,wB,bB,wR,bR,wQ,bQ,wP,bP,sk;

	// material
	i=0;
	for(bP=0;bP<=8;++bP) for(wP=0;wP<=8;++wP) for(bQ=0;bQ<=1;++bQ) for(wQ=0;wQ<=1;++wQ)
	for(bR=0;bR<=2;++bR) for(wR=0;wR<=2;++wR) for(bB=0;bB<=2;++bB) for(wB=0;wB<=2;++wB)
	for(bN=0;bN<=2;++bN) for(wN=0;wN<=2;++wN){// (9*2*3*3*3)^2=486^2=236,196.
		assert( i==wP*mat_key_mult[0]+bP*mat_key_mult[1]+wN*mat_key_mult[2]+bN*mat_key_mult[3]+wB*mat_key_mult[4]+bB*mat_key_mult[5]+wR*mat_key_mult[6]+bR*mat_key_mult[7]+wQ*mat_key_mult[8]+bQ*mat_key_mult[9] );
		sk=0;//init score

		// bishop pair(s)
		if( wB>=2 ) sk+=adj[O_BISHOP_PAIR];
		if( bB>=2 ) sk-=adj[O_BISHOP_PAIR];
		
		// penalty for no pawns
		if( !wP ) sk-=adj[O_PEN_NO_PAWN];
		if( !bP ) sk+=adj[O_PEN_NO_PAWN];

		// Penalty for no mating potential in pieces.
		if( wQ+wR==0 && (wN+wB<2 || wB==0) ) sk-=adj[O_PEN_NO_MATING_MAT];
		if( bQ+bR==0 && (bN+bB<2 || bB==0) ) sk+=adj[O_PEN_NO_MATING_MAT];

		assert(3*(wN+bN+wB+bB)+5*(wR+bR)+10*(wQ+bQ)<112);
		mh[i]=sk;
		i++;
	}

	// now init "ind1"
	if( ind1 ) return; // skip if already initialized
	unsigned int k=0,j,i1=0,i2=0,i3=0,i4=0,i5=0,i6=0,i7=0,i8=0;// each one is 0/1/2
	ind1=(unsigned short int*)malloc(sizeof(short)*6561);
	if( ind1==NULL ) exit(123);
	memset(ind1,0,sizeof(short)*6561);
	for(i=0;i<6561;++i){
		// update cell counters
		if( i ) i1=i1+1-3*(i1==2);
		if( i && (i%3)==0 ) i2=i2+1-3*(i2==2);
		if( i && (i%9)==0 ) i3=i3+1-3*(i3==2);
		if( i && (i%27)==0 ) i4=i4+1-3*(i4==2);
		if( i && (i%81)==0 ) i5=i5+1-3*(i5==2);
		if( i && (i%243)==0 ) i6=i6+1-3*(i6==2);
		if( i && (i%729)==0 ) i7=i7+1-3*(i7==2);
		if( i && (i%2187)==0 ) i8=i8+1-3*(i8==2);

		// transpose i into j
		j=i8+i7*3+i6*9+i5*27+i4*81+i3*243+i2*729+i1*2187;

		// assign
		if( i<=j ) ind1[i]=k++; // direct
		else ind1[i]=ind1[j]; // reuse existing one
	}

	// now init score mult
	/*if( mh2==NULL ){
		mh2=(short int*)malloc(sizeof(short int)*237000);
		memset(mh2,0,sizeof(short int)*237000);
		#define key_entries 2683
		static const int key[key_entries]={120,328,336,360,408,432,648,2929,2947,2953,2955,2956,2961,2979,3027,3028,3036,3060,3163,3169,3171,3172,3177,3187,3195,3196,3241,3243,3244,3249,3252,3267,3268,3276,3277,3324,3348,3483,3484,3492,3564,3891,3915,4131,4456,4464,4536,5104,5106,5112,5130,5836,5844,5860,5868,5872,5916,5940,5943,5952,6076,6079,6084,6085,6103,6111,6156,6157,6159,6160,6165,6168,6183,6184,6192,6240,6264,6399,6400,6408,6480,6807,6831,7047,7371,7372,7452,8019,8022,8028,8046,8055,8262,8751,8752,8760,8775,8776,8784,8832,
		8856,8859,8991,8992,9000,9001,9072,9075,9076,9084,9099,9100,9108,9156,9180,9315,9316,9324,9396,9723,9747,9963,10287,10935,10971,11178,11668,11692,11700,11907,11916,11988,11991,11992,12000,12015,12016,12024,12312,12879,13851,29164,29172,29173,29196,29197,29200,29205,29208,29244,29245,29253,29268,29269,29271,29272,29277,29280,29295,29304,29484,29485,29488,29493,29496,29520,29521,29565,29568,29592,29595,29808,29817,30132,30135,30159,30375,31347,31348,31356,31359,32077,32079,32080,32085,32088,32089,32103,32104,32107,32112,32113,32115,32116,32121,32124,32139,32140,32148,32160,
		32184,32187,32188,32196,32211,32220,32319,32320,32321,32323,32328,32329,32331,32332,32337,32347,32355,32356,32364,32400,32401,32403,32404,32409,32412,32413,32427,32428,32431,32436,32437,32439,32440,32481,32484,32508,32511,32643,32644,32652,32653,32724,32727,32728,32733,32736,32751,32752,32760,33048,33051,33075,33291,33535,33543,33615,33616,33624,33696,34263,34264,34266,34267,34272,34275,34290,34291,34299,34347,34371,34506,34507,34515,34587,34992,34993,34995,34996,35001,35004,35019,35020,35023,35028,35029,35031,35032,35040,35056,35076,35100,35103,35104,35112,35127,35136,35235,35236,35239,35244,
		35245,35253,35263,35271,35272,35316,35317,35319,35320,35325,35328,35343,35344,35347,35352,35353,35355,35356,35400,35424,35427,35559,35560,35568,35569,35640,35643,35644,35652,35667,35668,35676,35964,35967,35991,36207,36531,36532,36540,36612,37179,37180,37182,37183,37188,37191,37206,37207,37215,37263,37287,37422,37423,37431,37503,37530,37539,37908,37911,37912,37920,37935,37936,37944,37992,38016,38019,38028,38151,38152,38160,38161,38232,38233,38235,38236,38241,38244,38259,38260,38268,38271,38272,38316,38340,38475,38476,38484,38556,38583,38592,38883,38907,39123,40095,40098,40107,40122,40131,40338,
		40339,40347,40419,40446,40455,40852,40860,41148,41152,41160,41175,41176,41184,41472,42039,43011,43335,58320,58321,58324,58329,58332,58333,58336,58356,58357,58360,58365,58368,58392,58401,58404,58405,58407,58413,58428,58429,58431,58432,58437,58440,58455,58456,58464,58644,58645,58648,58653,58656,58657,58660,58680,58681,58684,58689,58692,58725,58728,58752,58755,58761,58764,58968,58969,58972,58977,58980,59004,59292,59295,59319,59535,60507,60508,60511,60516,60519,60543,60588,60591,60615,60831,60840,60843,60867,61236,61237,61239,61240,61245,61248,61249,61252,61263,61264,61266,61267,61268,61272,61273,
		61275,61276,61281,61284,61299,61300,61308,61317,61320,61323,61344,61347,61348,61353,61356,61371,61372,61380,61479,61480,61481,61483,61488,61489,61491,61492,61497,61500,61507,61515,61516,61524,61560,61561,61563,61564,61569,61572,61573,61576,61587,61588,61590,61591,61592,61596,61597,61599,61600,61605,61608,61623,61624,61632,61641,61644,61668,61671,61680,61803,61804,61812,61813,61816,61839,61840,61884,61885,61887,61888,61893,61896,61911,61912,61920,61924,62208,62211,62235,62451,62559,62703,62775,62776,62784,62856,63423,63424,63426,63427,63432,63435,63450,63451,63459,63463,63504,63507,63531,63534,
		63666,63667,63675,63676,63703,63747,63748,63750,63751,63756,63759,63774,63775,63783,63787,63855,63991,63999,64071,64083,64099,64107,64152,64153,64155,64156,64161,64164,64179,64180,64183,64188,64189,64191,64192,64200,64215,64216,64224,64236,64260,64263,64264,64272,64287,64296,64395,64396,64404,64405,64408,64413,64423,64431,64432,64440,64476,64477,64479,64480,64485,64488,64503,64504,64507,64512,64513,64515,64516,64524,64539,64540,64560,64584,64587,64596,64719,64720,64728,64729,64732,64755,64756,64800,64803,64804,64812,64827,64828,64836,64839,64840,65127,65151,65367,65403,65691,65700,66339,66340,
		66342,66343,66348,66351,66366,66367,66375,66423,66447,66450,66582,66583,66591,66619,66663,66666,66667,66672,66675,66690,66691,66694,66699,66702,66703,66771,66907,66915,66987,66999,67015,67023,67068,67071,67072,67080,67095,67096,67104,67108,67152,67176,67179,67312,67320,67348,67392,67395,67396,67404,67419,67420,67423,67428,67431,67432,67476,67500,67503,67636,67644,67716,67719,67720,67728,67743,67744,67752,68043,68067,68283,69255,69258,69267,69282,69283,69291,69363,69498,69499,69507,69579,69582,69583,69591,69606,69607,69615,69618,69831,69903,69939,70308,70344,72495,87480,87481,87484,87489,87492,
		87493,87496,87516,87517,87520,87525,87528,87552,87561,87564,87565,87567,87573,87588,87589,87591,87592,87597,87600,87615,87616,87624,87804,87805,87808,87813,87816,87817,87820,87828,87840,87841,87844,87849,87852,87876,87885,87888,87891,87912,87915,87916,87921,87924,87939,87948,88128,88129,88132,88137,88140,88144,88164,88165,88168,88176,88452,88455,88479,88488,88695,88731,88803,89667,89668,89671,89676,89679,89703,89704,89707,89715,89748,89751,89775,89778,89779,89787,89991,89992,89995,90000,90003,90007,90027,90028,90031,90039,90075,90099,90102,90111,90315,90319,90324,90327,90351,90355,90363,90396,
		90397,90399,90400,90405,90408,90409,90412,90423,90424,90427,90428,90432,90433,90435,90436,90444,90452,90459,90460,90468,90480,90483,90504,90507,90508,90516,90531,90532,90540,90543,90639,90640,90643,90648,90649,90651,90652,90657,90660,90667,90675,90676,90684,90720,90721,90723,90724,90728,90729,90732,90733,90736,90744,90747,90748,90751,90752,90756,90757,90759,90760,90765,90768,90772,90775,90776,90783,90784,90788,90792,90796,90804,90807,90828,90831,90832,90840,90855,90864,90963,90964,90972,90973,90976,90981,90984,90999,91000,91008,91044,91045,91047,91048,91053,91056,91060,91071,91072,91075,91076,
		91080,91083,91084,91092,91108,91112,91116,91120,91368,91371,91395,91398,91407,91611,91647,91695,91719,91935,91936,91944,92016,92268,92583,92584,92586,92587,92592,92595,92610,92611,92619,92622,92623,92631,92647,92664,92667,92691,92694,92703,92826,92827,92835,92836,92839,92862,92863,92871,92907,92908,92910,92911,92916,92919,92923,92934,92935,92938,92939,92943,92944,92946,92947,92955,92971,92975,92979,92983,92991,93015,93018,93019,93027,93150,93151,93159,93163,93187,93195,93199,93231,93234,93235,93243,93247,93258,93259,93262,93263,93267,93270,93271,93279,93283,93295,93299,93303,93307,93312,93315,
		93316,93321,93324,93339,93340,93343,93348,93351,93352,93360,93375,93376,93396,93420,93423,93424,93432,93447,93555,93556,93564,93565,93568,93591,93592,93600,93636,93637,93639,93640,93645,93648,93652,93663,93664,93667,93668,93672,93675,93676,93684,93699,93700,93708,93720,93744,93747,93756,93771,93879,93880,93888,93889,93892,93900,93916,93924,93960,93963,93964,93972,93987,93988,93991,93996,93999,94000,94008,94023,94024,94287,94311,94527,94563,94635,94860,95499,95502,95503,95508,95511,95526,95527,95535,95538,95539,95583,95607,95610,95742,95743,95751,95779,95823,95826,95827,95832,95835,95850,95851,
		95854,95859,95862,95863,95871,95887,95907,95931,95934,95943,96066,96067,96075,96079,96103,96111,96115,96147,96150,96151,96159,96174,96175,96178,96183,96186,96187,96195,96211,96214,96215,96223,96228,96232,96240,96255,96256,96264,96480,96508,96552,96555,96556,96564,96579,96580,96583,96588,96591,96592,96663,96796,96804,96832,96876,96879,96903,96904,96907,96912,96915,98415,98442,98451,98659,98667,98739,98742,98743,98751,98766,98767,98770,98775,98778,98779,98850,98983,98991,99019,99063,99066,99075,99090,99091,99094,99099,99102,99103,99130,116640,116641,116644,116649,116652,116653,116656,116664,116676,116677,
		116680,116685,116688,116692,116712,116716,116721,116724,116727,116748,116749,116751,116752,116757,116760,116775,116776,116784,116788,116964,116965,116968,116972,116973,116976,116977,116980,116988,117000,117001,117004,117008,117009,117012,117016,117036,117040,117045,117048,117051,117060,117072,117075,117076,117084,117088,117099,117100,117108,117112,117288,117289,117292,117297,117300,117301,117304,117312,117324,117325,117328,117332,117336,117340,117360,117364,117612,117615,117639,117648,117651,117855,117867,117883,117891,117939,117963,118827,118828,118831,118836,118839,118843,118863,118864,118867,118875,118908,118911,118935,118938,118939,118947,118962,118963,118971,119151,119152,119155,119160,
		119163,119164,119167,119175,119187,119188,119191,119195,119199,119203,119223,119227,119232,119235,119247,119259,119262,119263,119271,119275,119287,119295,119299,119475,119476,119479,119484,119487,119488,119491,119499,119511,119512,119515,119519,119523,119527,119547,119551,119555,119556,119557,119559,119560,119565,119568,119572,119583,119584,119587,119588,119592,119595,119596,119604,119612,119620,119624,119628,119632,119640,119664,119667,119668,119676,119691,119700,119799,119800,119808,119809,119812,119820,119836,119844,119848,119880,119881,119883,119884,119888,119889,119892,119893,119896,119904,119907,119908,119911,119912,119916,119917,119919,119920,119924,119928,119932,119935,119936,119943,
		119944,119948,119952,119956,119964,119967,119988,119991,119992,120000,120003,120015,120024,120027,120028,120123,120124,120132,120133,120136,120144,120152,120160,120164,120168,120172,120204,120207,120208,120212,120213,120216,120220,120228,120231,120232,120235,120236,120240,120243,120244,120248,120252,120256,120260,120267,120268,120272,120276,120280,120284,120528,120531,120555,120567,120771,120775,120783,120799,120807,120879,121095,121096,121104,121176,121428,121743,121744,121746,121747,121752,121755,121759,121770,121771,121775,121779,121782,121783,121791,121807,121811,121815,121819,121827,121851,121854,121855,121863,121878,121986,121987,121995,121996,121999,122007,122023,122031,122035,122067,
		122068,122070,122071,122075,122076,122079,122083,122091,122094,122095,122098,122099,122103,122104,122106,122107,122111,122115,122119,122123,122130,122131,122134,122135,122139,122143,122147,122151,122175,122178,122179,122187,122190,122202,122203,122211,122214,122215,122310,122311,122319,122320,122323,122331,122339,122346,122347,122351,122355,122359,122383,122391,122394,122395,122399,122400,122403,122407,122415,122418,122419,122422,122423,122427,122430,122431,122434,122435,122439,122443,122447,122454,122455,122458,122459,122463,122466,122467,122471,122472,122476,122484,122499,122500,122508,122512,122536,122580,122583,122716,122724,122728,122752,122760,122796,122799,122800,122808,122823,122824,
		122827,122828,122832,122835,122836,122844,122859,122860,122904,122907,122919,122931,122943,123040,123048,123052,123060,123076,123080,123084,123088,123120,123123,123124,123132,123136,123147,123148,123151,123152,123156,123159,123160,123163,123168,123183,123184,123187,123188,123196,123687,124659,124662,124663,124671,124686,124687,124695,124699,124767,124770,124903,124911,124915,124939,124983,124986,124987,124995,124999,125010,125011,125014,125015,125019,125022,125023,125031,125046,125047,125050,125051,125055,125059,125091,125094,125103,125106,125118,125122,125130,125134,125227,125235,125239,125247,125255,125263,125267,125271,125275,125307,125310,125311,125319,125322,125323,125334,125335,125338,
		125339,125343,125346,125347,125350,125351,125355,125358,125359,125362,125363,125370,125371,125374,125375,125378,125379,125382,125383,125386,125387,125712,125739,125751,126063,126075,126103,127902,127926,127938,128226,128250,128254,128259,128262,128266,128290,145800,145801,145804,145809,145812,145816,145824,145836,145837,145840,145848,145852,145872,145876,145884,145908,145911,145912,145920,145936,145944,146124,146125,146128,146132,146133,146136,146137,146140,146148,146160,146161,146164,146168,146172,146176,146196,146200,146204,146208,146220,146232,146235,146236,146244,146248,146259,146260,146268,146272,146448,146449,146452,146456,146457,146460,146461,146464,146472,146484,146485,146488,146492,
		146496,146500,146520,146524,146528,146772,146775,146799,146811,147015,147019,147027,147043,147051,147055,147123,147135,147987,147988,147991,147996,147999,148003,148011,148023,148027,148031,148035,148039,148059,148063,148071,148095,148098,148099,148107,148123,148131,148135,148311,148312,148315,148319,148320,148323,148324,148327,148335,148347,148348,148351,148355,148359,148363,148383,148387,148391,148395,148399,148407,148419,148422,148423,148431,148435,148446,148447,148451,148455,148458,148459,148463,148467,148471,148635,148636,148639,148643,148644,148647,148648,148651,148659,148671,148672,148675,148676,148679,148683,148684,148687,148707,148711,148715,148716,148720,148728,148732,148743,148744,
		148748,148752,148756,148764,148772,148780,148784,148788,148792,148824,148827,148960,148968,148972,148996,149004,149040,149043,149044,149048,149049,149052,149056,149064,149067,149068,149071,149072,149076,149079,149080,149084,149088,149092,149096,149104,149108,149112,149116,149120,149124,149127,149148,149151,149152,149160,149163,149175,149179,149184,149187,149188,149284,149292,149296,149304,149312,149320,149324,149328,149332,149364,149367,149368,149372,149376,149380,149388,149391,149392,149395,149396,149400,149403,149404,149408,149412,149416,149420,149428,149431,149432,149436,149440,149444,149931,149967,150264,150588,150592,150903,150907,150915,150919,150930,150931,150935,150939,150943,150951,
		150955,150967,150971,150975,150979,150987,151011,151014,151023,151038,151147,151155,151159,151183,151191,151195,151227,151230,151231,151235,151236,151239,151243,151251,151254,151255,151258,151259,151263,151266,151267,151271,151275,151279,151283,151290,151291,151294,151295,151299,151303,151307,151311,151335,151338,151339,151347,151350,151351,151362,151363,151366,151371,151374,151375,151471,151475,151479,151483,151491,151495,151499,151507,151511,151515,151519,151523,151535,151543,151547,151551,151554,151555,151559,151563,151566,151567,151575,151578,151579,151582,151583,151587,151590,151591,151594,151595,151599,151602,151603,151606,151607,151614,151615,151618,151619,151623,151626,151627,151630,
		151631,151668,151956,151960,151968,151983,151984,151992,151995,151996,152020,152067,152103,152200,152208,152212,152236,152280,152283,152284,152292,152307,152308,152311,152316,152319,152320,152323,152344,152347,152348,152356,152359,154143,154146,154147,154155,154170,154171,154174,154179,154182,154183,154207,154254,154266,154278,154282,154290,154294,154387,154395,154399,154423,154427,154431,154435,154467,154470,154471,154474,154479,154482,154483,154494,154495,154498,154499,154503,154506,154507,154510,154511,154515,154518,154519,154522,154523,154530,154531,154534,154535,154538,154539,154542,154543,154546,154547,174960,174964,174972,174976,174984,174996,175000,175004,175008,175012,175032,175036,
		175068,175080,175284,175288,175292,175293,175296,175300,175308,175320,175324,175328,175332,175336,175356,175360,175364,175368,175392,175395,175396,175404,175408,175420,175428,175432,175608,175612,175616,175620,175624,175632,175644,175648,175652,175656,175660,175680,175684,175688,177147,177151,177159,177163,177171,177183,177187,177191,177195,177199,177219,177223,177227,177231,177255,177267,177471,177475,177479,177480,177483,177487,177495,177507,177508,177511,177515,177519,177523,177543,177547,177551,177555,177567,177579,177582,177583,177591,177595,177607,177611,177615,177619,177623,177627,177631,177795,177799,177803,177804,177807,177808,177811,177819,177831,177832,177835,177836,177839,177843,
		177844,177847,177867,177868,177871,177872,177875,177876,177880,177888,177904,177912,177916,177940,178200,178204,178212,178216,178228,178232,178236,178240,178248,178252,178256,178264,178268,178272,178276,178311,178444,178452,178456,178480,178484,178488,178492,178524,178528,178532,178536,178540,178548,178552,178556,178560,178563,178564,178568,178572,178576,178580,178588,178592,178596,178600,178604,180063,180067,180075,180091,180099,180103,180111,180127,180131,180139,180343,180387,180391,180399,180403,180411,180415,180419,180423,180427,180431,180435,180439,180443,180451,180455,180459,180463,180467,180495,180498,180507,180510,180534,180535,180631,180639,180643,180651,180659,180667,180671,180675,
		180679,180683,180695,180703,180707,180711,180714,180715,180719,180723,180727,180735,180738,180739,180742,180743,180747,180750,180751,180754,180755,180759,180762,180763,180767,180774,180775,180778,180779,180783,180786,180787,180790,180791,183658,183663,183666,183667,183670,183691,183694,183695,183706,204120,204124,204132,204136,204156,204160,204168,204172,204196,204444,204448,204456,204460,204468,204480,204484,204488,204492,204496,204516,204520,204524,204768,204772,204776,204780,204784,204792,204804,204808,204812,204816,204820,204840,204844,204848,206307,206311,206319,206323,206331,206343,206347,206351,206355,206359,206379,206383,206387,206631,206635,206639,206643,206647,206655,206667,206671,
		206675,206679,206683,206703,206707,206711,206715,206739,206743,206751,206755,206767,206775,206779,206783,206955,206959,206963,206967,206971,206979,206991,206995,206999,207003,207007,207027,207031,207035,207684,207688,207696,207712,207720,207724,207748,207752,207760,209583,209827,209871,209875,209883,209887,209895,209899,209903,209907,209911,209915,209919,209923,209927,209935,209939,209943,209947,209951,233928,233932,233940,233944,233964,233968,233972,233976,233980,234004,234008,236115,236119,236123,236127,236131,236139,236151,236155,236159,236163,236167,236187,236191,236195};
		static const short int value[key_entries]={114,-896,-752,-896,216,-22,-704,604,-502,536,-638,-670,304,-772,-282,178,498,1372,1604,318,1136,-170,408,1522,78,-38,376,-426,-390,672,-320,-422,-400,-386,2000,396,420,952,444,-340,-78,-30,132,-888,234,100,272,872,-674,194,-896,94,104,146,-176,-148,708,1184,-24,1004,-120,992,-64,550,886,314,128,1204,-224,-38,588,150,-272,106,330,166,918,896,-238,-204,-14,-20,350,-294,-334,286,436,396,-458,2000,-860,-182,944,538,524,532,422,686,-20,178,
		2000,534,712,252,400,2000,208,-216,240,374,-36,364,484,-76,142,132,-238,42,-112,1014,2000,-134,38,78,152,638,1240,456,150,494,640,-56,-222,2000,2000,172,2000,2000,-24,-332,4,-58,-56,508,-674,618,-472,276,-124,44,570,2000,-162,578,110,338,308,358,730,-70,-106,322,-68,558,-84,-312,932,264,172,340,194,-230,642,-42,-482,-294,-158,480,212,310,-572,196,-76,-104,382,90,1454,-178,-158,264,-282,2000,60,-182,292,58,130,-168,16,500,
		462,66,822,530,138,412,-22,-128,124,806,-302,488,104,-150,1022,744,90,2,-120,144,414,42,-54,764,0,476,50,24,-38,0,256,170,-138,226,246,350,422,452,42,68,278,10,214,58,2000,60,152,168,2,18,4,140,-476,-108,-90,-80,-372,-404,436,230,2000,288,-214,408,-258,12,-262,-528,-2,710,894,40,-192,-16,222,180,50,230,2000,440,84,494,-148,-64,2000,-28,162,226,192,260,306,428,2000,452,304,2000,152,228,324,36,
		504,392,158,104,-86,276,430,-188,126,648,260,-148,266,132,234,2000,54,308,30,330,122,142,16,158,620,104,-336,168,204,48,344,116,-264,318,320,-222,122,292,-52,262,258,-46,-190,374,414,676,-202,250,-76,34,440,382,-354,-274,536,70,34,10,724,232,568,570,988,178,2000,400,442,130,530,50,202,552,116,2000,-30,14,780,238,4,138,238,36,-34,2000,568,112,20,204,-52,14,336,282,100,-204,-102,-336,200,-356,250,170,
		8,-70,136,122,178,348,212,-4,134,-56,362,406,112,-26,-228,-204,2000,130,370,40,630,102,866,-416,-312,556,-356,542,18,250,-18,292,934,622,2000,130,-122,322,306,90,262,494,272,366,180,356,-58,542,24,284,-360,-8,490,34,402,-128,308,206,150,222,1584,114,-116,312,-32,146,206,-66,140,-338,-64,-334,198,552,-366,1084,-400,-552,248,294,156,-194,474,100,-354,694,304,586,72,416,266,892,-128,482,210,272,264,148,-180,462,
		210,-88,328,152,270,-190,402,-280,250,-74,358,224,634,2000,388,90,376,272,272,44,210,214,-54,522,148,96,682,2,876,58,196,-4,86,310,180,22,390,30,342,192,250,126,64,194,72,22,1058,278,180,-50,198,204,208,224,-274,82,212,358,-116,132,38,78,544,298,130,0,-2,74,214,234,658,156,278,210,48,180,-52,-38,432,-376,364,-150,56,-464,-226,76,180,116,426,72,226,116,358,42,-304,-68,26,238,230,174,
		164,28,-122,220,-88,6,306,198,296,502,280,174,76,-82,98,320,-132,-158,14,154,70,-58,418,-32,200,238,74,360,512,516,444,-56,2000,24,256,692,516,44,380,78,136,454,250,122,390,2000,258,84,154,362,-42,2000,308,134,274,480,194,2000,-12,20,672,152,4,152,-6,202,2000,30,120,112,64,12,256,258,162,340,52,318,274,366,128,182,268,32,-16,78,226,364,386,166,20,84,140,206,-182,470,6,-16,128,90,
		128,360,144,166,16,314,126,38,144,174,216,-148,-262,-126,304,28,384,352,192,136,94,108,126,242,232,326,-126,162,110,44,86,168,-30,400,334,2000,462,372,274,434,96,194,630,-76,194,304,114,76,86,206,206,28,-234,102,66,172,-2,-36,456,102,314,8,144,48,684,246,52,52,490,152,-164,50,-66,326,38,516,238,2000,74,66,54,286,-150,228,82,-96,336,186,114,200,52,-70,38,188,66,694,592,44,502,314,
		466,-136,-214,546,-104,1204,38,6,-76,306,176,-68,1128,184,206,162,352,186,388,398,454,316,134,328,16,380,118,376,12,174,40,252,128,490,108,356,136,98,292,66,342,82,2000,64,634,132,-82,98,148,494,198,20,-30,162,144,222,0,-190,26,416,-236,520,32,-18,334,-284,438,-196,-400,310,-270,-342,-50,258,150,230,316,258,-154,256,78,224,-22,204,-32,206,-34,104,362,190,546,370,-66,236,254,-76,-68,128,210,716,
		126,532,122,152,298,486,-98,670,320,882,304,-170,408,330,70,234,266,338,-100,138,248,100,74,304,238,200,332,438,286,66,86,52,302,142,382,124,302,346,308,454,10,154,-20,52,270,132,14,148,228,116,158,-32,180,220,148,170,268,64,432,178,120,2000,194,-66,158,418,762,184,128,208,356,78,458,-20,508,-18,104,812,2,-110,128,54,226,132,238,176,96,114,208,18,-88,36,56,258,152,2,148,156,248,242,
		152,216,150,208,84,206,214,130,-204,74,346,-238,652,-416,180,-78,196,10,-152,156,-82,-380,98,228,414,72,220,58,482,226,-158,224,72,44,30,-92,326,106,-114,342,158,128,102,610,308,-168,198,116,74,164,190,208,86,226,138,226,152,94,220,50,126,182,216,244,234,430,386,372,226,52,12,66,48,-186,276,84,176,106,456,162,122,-46,244,188,158,54,94,160,8,104,98,106,384,540,370,44,304,182,282,438,
		142,-222,300,706,344,628,-40,290,204,-32,600,-108,208,28,860,-80,314,218,34,390,164,280,90,-52,298,278,160,118,34,6,2000,158,114,182,186,332,32,156,304,166,584,366,226,330,216,44,430,152,-100,6,240,96,-36,-78,660,220,960,-6,30,76,224,204,266,242,94,356,210,416,82,-10,398,232,-120,162,162,-322,94,194,340,200,316,170,382,88,460,230,242,336,-146,94,116,82,144,228,26,180,-2,254,160,202,
		18,112,152,324,318,82,246,166,162,224,-220,18,174,64,400,390,-60,278,216,158,254,198,114,180,196,110,104,90,218,-8,170,112,42,430,34,494,2000,-88,-18,76,120,64,184,420,164,50,128,104,120,150,-84,74,110,380,114,296,66,-8,420,144,254,-90,270,34,90,370,118,-188,68,370,92,324,60,190,422,516,482,104,130,348,214,282,530,112,-74,-58,136,70,98,-10,604,120,256,236,290,556,-64,290,-72,298,
		84,378,184,24,-10,-178,-246,132,-120,206,334,218,312,1232,364,686,282,192,178,184,92,42,48,266,196,-10,6,354,50,288,168,104,300,186,16,176,260,18,112,634,40,50,374,76,130,30,460,-180,74,204,-12,24,188,130,100,96,66,182,102,68,28,-72,132,120,-38,316,-42,-92,-16,-142,304,-366,172,508,346,32,352,-132,148,-336,104,-162,-56,-274,156,-228,-260,52,190,254,726,80,208,300,64,332,-64,106,60,142,
		74,44,170,384,10,0,114,46,158,84,308,22,-68,220,232,84,554,188,118,-72,82,252,28,-64,48,90,-16,66,32,118,366,30,130,134,-50,200,112,354,80,6,450,48,216,104,-104,276,-72,412,398,208,308,-176,374,154,268,418,82,-52,348,240,266,106,34,404,268,328,180,-192,360,210,208,408,346,184,10,690,76,86,110,54,248,218,200,46,170,160,176,184,158,98,116,238,172,112,250,146,126,176,94,-30,
		96,120,234,202,152,510,164,248,-104,136,456,1172,-88,438,-96,-76,54,64,558,74,124,176,48,144,-90,160,58,44,66,164,176,136,188,226,194,148,-56,90,98,-72,154,264,176,166,256,-6,170,284,304,34,90,2000,372,190,420,-236,-130,116,284,-44,30,-196,70,268,-324,316,68,138,90,190,140,152,340,244,370,68,-70,98,180,172,-20,262,18,316,192,18,46,202,94,322,-26,104,180,552,138,300,182,-6,-130,170,
		14,26,186,324,82,226,200,154,24,236,166,264,122,138,-38,278,352,246,332,260,-32,188,-196,190,210,320,486,114,156,272,214,250,24,366,60,68,364,198,-152,286,160,174,202,228,72,-164,218,12,192,152,42,132,-14,228,162,-36,206,232,194,-2,136,136,248,182,18,206,124,324,230,248,180,-204,172,-120,332,366,-96,228,274,268,212,206,624,454,-94,210,140,28,1080,568,418,446,348,430,84,140,106,106,262,148,
		94,242,116,336,138,262,210,94,48,414,462,964,306,288,140,8,858,244,388,256,394,74,-6,-24,296,18,166,136,44,348,144,244,134,322,118,86,104,56,424,86,-148,114,52,496,256,248,214,22,60,106,376,190,72,202,182,208,222,186,222,496,116,328,126,662,124,218,122,242,148,76,168,370,188,278,206,264,218,314,520,-166,-76,192,144,96,246,370,370,194,162,126,262,342,298,146,288,50,484,278,330,40,
		88,252,158,252,22,278,146,60,270,152,318,144,194,44,342,102,152,152,178,140,-34,2000,242,-140,640,60,266,-58,134,330,-6,36,84,78,138,320,108,338,28,328,-36,326,82,314,-94,114,110,142,-70,224,78,316,244,214,376,368,592,74,160,32,210,350,-14,228,46,180,318,104,-30,174,-10,130,156,332,344,152,10,24,106,372,-48,78,146,370,-50,-38,36,0,-94,120,234,-86,112,132,106,96,140,-178,144,214,
		170,110,50,306,56,-184,-14,254,470,-116,82,-156,554,112,-284,14,-156,-164,20,-50,166,46,-74,-12,-228,74,258,-66,46,-60,100,-20,130,250,180,204,284,232,306,-44,-70,60,22,-38,154,86,104,222,54,4,144,48,116,134,218,234,160,170,106,134,292,250,156,192,132,168,18,-118,70,-2,60,104,48,-122,28,-26,146,290,-118,116,-256,76,240,142,-114,130,-48,132,174,-212,196,236,182,276,224,66,142,88,230,286,
		-72,-108,110,272,410,102,-90,144,342,496,-260,448,264,458,116,414,56,54,66,-28,-4,98,164,280,4,154,2,66,114,92,136,-12,78,128,380,118,194,426,284,112,234,446,440,338,-42,56,96,692,386,24,186,-50,-42,-12,-46,-114,24,10,100,-64,-34,118,-18,112,206,162,266,304,180,164,90,186,132,-72,178,124,104,250,146,230,-254,236,300,280,304,-172,524,414,-314,-42,10,242,200,270,-20,280,136,40,142,40,
		134,-4,-228,400,2,-118,-38,-36,324,884,96,288,12,146,300,-96,144,-76,98,420,-62,232,196,276,-50,284,46,220,102,52,122,270,158,150,258,-64,176,-266,318,172,230,318,80,126,234,-44,194,78,146,458,-28,388,192,144,24,214,42,118,10,178,330,120,96,76,-30,52,194,-190,-142,90,140,-100,248,166,250,-6,312,276,-62,242,40,228,198,-122,200,-142,266,226,-80,224,-100,170,-320,314,-248,190,248,-344,270,-238,
		194,30,112,220,162,570,154,416,306,-62,182,-114,-140,526,104,332,-54,258,-38,344,190,208,394,212,72,210,498,634,80,-6,38,296,-172,212,116,234,-220,340,214,8,84,362,-6,112,354,322,422,86,-108,74,218,212,48,256,306,-24,704,130,-32,214,196,242,182,412,358,242,108,312,238,158,240,98,294,82,188,138,476,310,-22,268,96,202,72,-44,60,220,-106,174,22,70,216,188,-166,-136,-60,-274,-102,98,-46,-178,
		288,-86,88,188,132,-122,184,130,394,88,196,112,138,140,90,216,236,46,32,40,-40,-24,-98,-28,172,-52,108,52,-58,156,146,190,40,138,224,168,200,-62,292,218,-338,48,-66,136,112,-182,-18,-74,-46,6,-44,4,38,-80,-78,262,-12,148,-26,-224,124,164,122,66,-208,136,34,72,62,222,90,88,76,-24,6,130,48,166,-42,-110,88,-48,-76,28,-52,-64,14,184,44,-166,144,-322,162,242,126,-266,198,-448,74,182,
		-340,186,152,-418,224,-516,182,-106,-86,122,36,-230,78,398,-6,172,38,108,108,-142,26,88,62,124,-56,146,434,676,8,18,-186,-290,-140,-144,-108,-316,46,126,114,128,102,260,308,90,140,164,-130,168,254,66,264,170,210,354,232,176,310,12,92,66,630,14,196,50,192,240,88,302,102,90,162,180,466,246,14,50,162,266,-32,44,-36,182,254,252,242,70,-454,202,-84,-242,76,314,-76,258,-110,210,164,2,-38,12,
		4,26,-124,-38,-396,136,-302,232,146,234,220,212,-238,248,-6,198,188,-266,186,-148,152,214,-188,82,318,-440,230,-338,198,202,-502,222,-318,162,74,156,288,380,304,-90,-148,310,-10,-168,-260,-272,18,-266,-300,-164,-186,-838,10,314,76,196,-26,94,88,56,210,380,2,62,132,48,212,-32,92,-24,256,-38,34,28,26,136,-192,110,34,-494,-170,-162,-50,-174,-114,-358,70,-30,-198,-392,-146,-2,-60,212,266,46,288,254,172,112,
		-164,-52,120,-66,72,-30,-184,112,-250,280,170,-382,50,-74,78,104,94,-30,112,80,104,94,98,84,62,92,84,116,126,-186,222,254,114,-128,-46,220,228,-56,-88,798,-22,-96,66,412,160,392,350,284,120,54,-84,-58,108,232,92,186,82,190,-524,-258,-276,-98,-64,-204,-314,-74,-126,56,-130,-154,-204,-204,68,-78,280,-170,-102,-134,-30,-54,-328,-48,-44};
		i=0;
		for(bP=0;bP<=8;++bP) for(wP=0;wP<=8;++wP) for(bQ=0;bQ<=1;++bQ) for(wQ=0;wQ<=1;++wQ)
		for(bR=0;bR<=2;++bR) for(wR=0;wR<=2;++wR) for(bB=0;bB<=2;++bB) for(wB=0;wB<=2;++wB)
		for(bN=0;bN<=2;++bN) for(wN=0;wN<=2;++wN){// (9*2*3*3*3)^2=486^2=236,196.
			int k=bP*mat_key_mult[0]+wP*mat_key_mult[1]+bN*mat_key_mult[2]+wN*mat_key_mult[3]+bB*mat_key_mult[4]+wB*mat_key_mult[5]+bR*mat_key_mult[6]+wR*mat_key_mult[7]+bQ*mat_key_mult[8]+wQ*mat_key_mult[9];
			k=min(k,int(i));
			// find key
			for(j=0;j<key_entries;++j)
				if( k==key[j] ){
					mh2[i]=value[j];// set it
					break;
				}else if( k<key[j] )
					break;
			i++;
		}
	}*/
}

//int some_coeffs[100];
short int knight_outpost_value_m[64];// for knight on opp part of the board not attackable by opp pawns and protected by own pawn.
short int knight_outpost_value2_m[64];// Extra if opp has no minor piece for exchange.

static const UINT64 bishop_color_masks[2]={0xaa55aa55aa55aa55,0x55aa55aa55aa55aa};
// base_king_attacks contain penalties based on the position of the
// defending king, indexed by king's square (from white's point of view).
static const unsigned int base_king_attacks[64]={// 9/25/2016 version
	4, 2, 7,15,15,15,15,15,
	1, 1,10,15,15,15,15,15,
	5, 5,14,15,15,15,15,15,
	6, 9,16,15,15,15,15,15,
	6, 9,16,15,15,15,15,15,
	5, 5,14,15,15,15,15,15,
	1, 1,10,15,15,15,15,15,
	4, 2, 7,15,15,15,15,15};


static const int KSscale[43]={0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  9,13,17,19, 20,24, 20,22,24,24,26,26,28,30,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32,32};// 32X, for total piece value, 0 to max=10+2*5+2*3+2*3=10+10+12=32. Extend the table to cover multiple queens (yes, it happens).
//							  0  1  2  3  4  5  6  7  8  9  Q  11 12 QN 14 QR QNN 17 QRN 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42

#if TRAIN
extern _declspec(thread) int pawn_deriv_coeffs[7000];
extern _declspec(thread) unsigned int use_hash;
extern _declspec(thread) board_light *eval_b; // evaluation boards
extern _declspec(thread) short int *eval_score; // evaluation scores
extern _declspec(thread) unsigned int eval_counter; // count of eval calls
extern int ka[2];
static const unsigned int bishop_outpost_cell[64]={
		0,0,0, 0, 0, 0,0,0,
		0,0,0, 0, 1, 2,0,0,
		0,0,3, 4, 5, 6,0,0,
		0,0,7, 8, 9,10,0,0,
		0,0,7, 8, 9,10,0,0,
		0,0,3, 4, 5, 6,0,0,
		0,0,0, 0, 1, 2,0,0,
		0,0,0, 0, 0, 0,0,0};
#endif
// deriv coeffs:
// 0-8: knight mob (9)
// 9-22: bishop mob (14)
// 23-37: rook mob (15)
// 38-65: queen mob (28)
// 66-87: knight outpost (11+11)
// 88: rook pinning queen
// 89,90: rook on open/semi-open file
// 91-98: rook behind my passed pawn (8)
// 99-160: king safety (62)
// 161-176: kings close to passed pawn (16)
// 177: unstoppable passed pawn
// 183: rook pinning king
// 184-185: bishop pinning king or queen
// 186-201: kings close to passed pawn, with opp piece (16)
// 203-206: king mob endgame
// 207: rook protecting other rook
// 208-229: bishop outpost (11+11)
// 230-294: knight outpost (32+32)
// 295-301: attacks (7)
// 302: parity
// 303: free

#define LOG_STEPS 0

template <EvalType> int evall(board*);
int eval(board *b){
	if( b->piececolorBB[4][0]|b->piececolorBB[4][1] ) return(evall<Full>(b));
	else return(evall<NoQueens>(b));
}

typedef struct{
	unsigned int lock;
	int s;
} eTT; // 8 bytes

// flips: 0=as is, 1=w-b, 2=l-r, 3=w-b and l-r, 4=to 48, 5=to 48 w-b, 6=to 48 l-r, 7=to 48 w-b and l-r
const unsigned char flips[64][8]={0,7,56,63,0,6,41,47,1,6,57,62,0,5,42,47,2,5,58,61,1,4,43,46,3,4,59,60,2,3,44,45,4,3,60,59,3,2,45,44,5,2,61,58,4,1,46,43,6,1,62,57,5,0,47,42,7,0,63,56,6,0,47,41,
8,15,48,55,5,12,35,42,9,14,49,54,6,11,36,41,10,13,50,53,7,10,37,40,11,12,51,52,8,9,38,39,12,11,52,51,9,8,39,38,13,10,53,50,10,7,40,37,14,9,54,49,11,6,41,36,15,8,55,48,12,5,42,35,16,23,40,47,11,18,29,36,17,
22,41,46,12,17,30,35,18,21,42,45,13,16,31,34,19,20,43,44,14,15,32,33,20,19,44,43,15,14,33,32,21,18,45,42,16,13,34,31,22,17,46,41,17,12,35,30,23,16,47,40,18,11,36,29,24,31,32,39,17,24,23,30,25,30,33,38,18,23,24,29,
26,29,34,37,19,22,25,28,27,28,35,36,20,21,26,27,28,27,36,35,21,20,27,26,29,26,37,34,22,19,28,25,30,25,38,33,23,18,29,24,31,24,39,32,24,17,30,23,32,39,24,31,23,30,17,24,33,38,25,30,24,29,18,23,34,37,26,29,25,28,19,
22,35,36,27,28,26,27,20,21,36,35,28,27,27,26,21,20,37,34,29,26,28,25,22,19,38,33,30,25,29,24,23,18,39,32,31,24,30,23,24,17,40,47,16,23,29,36,11,18,41,46,17,22,30,35,12,17,42,45,18,21,31,34,13,16,43,44,19,20,32,33,
14,15,44,43,20,19,33,32,15,14,45,42,21,18,34,31,16,13,46,41,22,17,35,30,17,12,47,40,23,16,36,29,18,11,48,55,8,15,35,42,5,12,49,54,9,14,36,41,6,11,50,53,10,13,37,40,7,10,51,52,11,12,38,39,8,9,52,51,12,11,39,38,9,8,
53,50,13,10,40,37,10,7,54,49,14,9,41,36,11,6,55,48,15,8,42,35,12,5,56,63,0,7,41,47,0,6,57,62,1,6,42,47,0,5,58,61,2,5,43,46,1,4,59,60,3,4,44,45,2,3,60,59,4,3,45,44,3,2,61,58,5,2,46,43,4,1,62,57,6,1,47,42,5,0,63,56,7,0,47,41,6,0};

// lookup table for base 2 to base 3 conversion.
#if TRAIN==0
const
#endif
unsigned short int convert2_3[256]={0,1,3,4,9,10,12,13,27,28,30,31,36,37,39,40,81,82,84,85,90,91,93,94,108,109,111,112,117,118,120,121,243,244,246,247,252,253,255,256,270,271,273,274,279,280,282,283,324,325,327,328,333,334,336,337,351,352,354,355,360,361,363,364,729,730,732,733,738,739,741,742,756,757,759,760,765,766,768,769,810,811,813,814,819,820,822,823,837,838,840,841,846,847,849,850,972,973,975,976,981,982,984,985,999,1000,1002,1003,1008,1009,1011,1012,1053,1054,1056,1057,1062,1063,1065,1066,1080,1081,1083,1084,1089,1090,1092,1093,2187,2188,2190,2191,2196,2197,2199,2200,2214,2215,2217,2218,2223,2224,2226,2227,2268,2269,2271,2272,2277,2278,2280,2281,2295,2296,2298,2299,2304,2305,2307,2308,2430,2431,2433,2434,2439,2440,2442,2443,2457,2458,2460,2461,2466,2467,2469,2470,2511,2512,2514,2515,2520,2521,2523,2524,2538,2539,2541,2542,2547,2548,2550,2551,2916,2917,2919,2920,2925,2926,2928,2929,2943,2944,2946,2947,2952,2953,2955,2956,2997,2998,3000,3001,3006,3007,3009,3010,3024,3025,3027,3028,3033,3034,3036,3037,3159,3160,3162,3163,3168,3169,3171,3172,3186,3187,3189,3190,3195,3196,3198,3199,3240,3241,3243,3244,3249,3250,3252,3253,3267,3268,3270,3271,3276,3277,3279,3280};
// evaluation function
short int pass_forward_b(board*);
template <EvalType ET1> int evall(board *b){
	#if TRAIN==0
	volatile UINT64 *h1;
	eTT h1d;
	#endif
	short *adj2;
	UINT64 bb,bb_2,attack_mask,one,km[2],o,attacks[6][2];// 0=current, 1=pawns, 2=..., 3=P+N+B, 4=P+N+B+R, 5=P+N+B+R+Q. 0=white attacks black, 1=black attacks white.
	unsigned long bit,bit2;
	unsigned int d,king_attack_units[2],total_piece_value[2],index;
	int sk;
	short int sk2[2];

	// look in eval hash table - only if not training set work
	#if TRAIN==0
	h1=&eh[get_eval_hash_index];
	h1d=((eTT*)h1)[0]; // atomic read
	if( h1d.lock==((unsigned int*)&b->hash_key)[1] ) return(h1d.s);
	h1d.lock=((unsigned int*)&b->hash_key)[1];
	#endif

	_mm_prefetch((const char*)&ph[b->pawn_hash_key%PHSIZE],_MM_HINT_T0); // prefetch pawn hash
	sk=mh[b->mat_key];// material key
	((int*)sk2)[0]=0;//init
	total_piece_value[0]=total_piece_value[1]=0;
	one=1;// init

	// comment out for training, uncomment for games
	sk+=pass_forward_b(b); // add NN result
	
	// get the list of all pawns**********************************************
	unsigned int pw=0,pb=0,pawns_wa[2][8],pawns_ba[2][8];
	bb=b->piececolorBB[0][0];
	while( bb ){
		GET_BIT(bb)
		pawns_wa[0][pw]=2*flips[bit][0+4];
		pawns_wa[1][pw++]=2*flips[bit][2+4];
	}
	bb=b->piececolorBB[0][1];
	while( bb ){
		GET_BIT(bb)
		pawns_ba[0][pb]=2*flips[bit][1+4];
		pawns_ba[1][pb++]=2*flips[bit][3+4];
	}
	
	// loop over all pieces*******************************************
	bb=(b->colorBB[0]|b->colorBB[1])^(b->piececolorBB[0][0]|b->piececolorBB[0][1]); // excl P
	while( bb ){
		GET_BIT(bb)
		unsigned int color=b->piece[bit]>>7;	// 0/1
		unsigned int type=b->piece[bit]&7;		// 1-6
		if( bit<32){// none vs l/r flip: none
			adj2=adj+O_KP+2*48*(bit*10+(type-2+color*5));						// 48 pawn squares, 10 piece types, mid+end. // piece: N/B/R/Q/K=0/1/2/3/4. n/b/r/q/k=5/6/7/8/9.
			for(d=0;d<pw;++d) ((int*)sk2)[0]+=((int*)&adj2[pawns_wa[0][d]])[0]; // loop over W pawns
			adj2=adj+O_KP+2*48*(flips[bit][1]*10+(type-2+5-color*5));			// 48 pawn squares, 10 piece types, mid+end. // piece: N/B/R/Q/K=0/1/2/3/4. n/b/r/q/k=5/6/7/8/9.
			for(d=0;d<pb;++d) ((int*)sk2)[0]-=((int*)&adj2[pawns_ba[0][d]])[0]; // loop over W pawns
		}else{// none vs l/r flip: l/r flip
			adj2=adj+O_KP+2*48*(flips[bit][2]*10+(type-2+color*5));				// 48 pawn squares, 10 piece types, mid+end. // piece: N/B/R/Q/K=0/1/2/3/4. n/b/r/q/k=5/6/7/8/9.
			for(d=0;d<pw;++d) ((int*)sk2)[0]+=((int*)&adj2[pawns_wa[1][d]])[0]; // loop over W pawns
			adj2=adj+O_KP+2*48*(flips[bit][3]*10+(type-2+5-color*5));			// 48 pawn squares, 10 piece types, mid+end. // piece: N/B/R/Q/K=0/1/2/3/4. n/b/r/q/k=5/6/7/8/9.
			for(d=0;d<pb;++d) ((int*)sk2)[0]-=((int*)&adj2[pawns_ba[1][d]])[0]; // loop over W pawns
		}
	}

	// rank 1, W+2*B
	// first, need to turn the board: make bits 0/8/16/24/32/40/48/56 into bits 0/1/2/3/4/5/6/7
	index=convert2_3[(b->colorBB[0]&0x101010101010101)*0x0102040810204080>>56];
	index+=convert2_3[(b->colorBB[1]&0x101010101010101)*0x0102040810204080>>56]*2;// 6561
	index=ind1[index];	
	((int*)sk2)[0]+=((int*)&adj[O_R1+index*2])[0];

	// rank 8, B+2*W
	// first, need to turn the board: make bits 7+0/8/16/24/32/40/48/56 into bits 0/1/2/3/4/5/6/7
	index=convert2_3[((b->colorBB[1]>>7)&0x101010101010101)*0x0102040810204080>>56];
	index+=convert2_3[((b->colorBB[0]>>7)&0x101010101010101)*0x0102040810204080>>56]*2;// 6561
	index=ind1[index];
	((int*)sk2)[0]-=((int*)&adj[O_R1+index*2])[0];

	#if LOG_STEPS
	FILE *fl=fopen("c://xde//chess//out//eval_log.csv","a");
	fprintf(fl,"PST is:%d,%d\n",b->scorem,b->scoree);
	fprintf(fl,"descr,sk,sk2[0],sk2[1]\n");
	fprintf(fl,"material scores,%d,%d,%d\n",sk,sk2[0],sk2[1]);
	#endif
	
	if( ET1==Full ){
		king_attack_units[0]=king_attack_units[1]=0;// init
		km[0]=king_masks[b->kp[0]]|(one<<b->kp[0]);// extended white king attack mask
		if( (b->kp[0]&7)<=3 ) km[0]|=king_masks[b->kp[0]]<<1; // only extend it forward if king is on ranks 0 1 2 3
		km[1]=king_masks[b->kp[1]]|(one<<b->kp[1]);// extended black king attack mask
		if( (b->kp[1]&7)>=4 ) km[1]|=king_masks[b->kp[1]]>>1; // only extend it forward if king is on ranks 7 6 5 4
	}

	// pawn attack/defend masks
	attacks[0][1]=attacks[1][1]=(b->piececolorBB[0][1]<<7)|(b->piececolorBB[0][1]>>9);// black pawns attack
	attacks[0][0]=attacks[1][0]=(b->piececolorBB[0][0]<<9)|(b->piececolorBB[0][0]>>7);// white pawns attack
	o=b->colorBB[0]|b->colorBB[1];// occupied by either

	#if calc_pst==1
	((int*)sk2)[0]+=((int*)&piece_square[5][0][b->kp[0]][0])[0];// white K PST
	((int*)sk2)[0]+=((int*)&piece_square[5][1][b->kp[1]][0])[0];// black K PST
	#endif

	// process pieces
	// knights
	bb=b->piececolorBB[1][0];
	while( bb ){// loop over white knights
		GET_BIT(bb)

		// N opp B patterns
		bb_2=b->piececolorBB[2][1];
		while( bb_2 ){// loop over black bishops
			GET_BIT2(bb_2)
			unsigned int index;
			if( bit<32 ) index=bit+bit2*32;
			else index=flips[bit][2]+flips[bit2][2]*32;// l-r only
			((int*)sk2)[0]+=((int*)&adj[O_NB+index*2])[0];
		}

		#if calc_pst==1
		((int*)sk2)[0]+=((int*)&piece_square[1][0][bit][0])[0];// white N PST
		#endif
		attack_mask=knight_masks[bit];
		attacks[0][0]|=attack_mask;
		d=(unsigned int)popcnt64l(attack_mask&~(attacks[1][1]|b->colorBB[0])); // exclude occupied/attacked cells
		if( ET1==Full ) king_attack_units[1]+=2*(unsigned int)popcnt64l(attack_mask&km[1]); // black king attack units - 2 for knights
		((int*)sk2)[0]+=((int*)&adj[O_N_MOB+d*2])[0];
		//((int*)sk2)[0]+=((int*)&adj[O_N_MOB2+2*(d*32+flips[bit][(bit>>4)&2])])[0]; // mob2
		#if TRAIN
		pawn_deriv_coeffs[0+d]++;// knight mob
		#endif

		// check for white N outpost
		if( ((bb_2=(one<<bit))&0x00383c3c3c3c3800) && !(bb_2&attacks[1][1]) ){// not attacked by opp and on 22 cells
			if( (bb_2&0x0000383838380000) && (bb_2&attacks[1][0]) && (b->piece[bit-6]!=128+1 || b->piece[bit-7]) && (b->piece[bit+10]!=128+1 || b->piece[bit+9]) ){// in small outpost zone - 12 cells. Protected by a pawn. Not attacked by a pawn, even after 1 move forward
				#if TRAIN
				pawn_deriv_coeffs[230+bishop_outpost_cell[bit]]++;// knight outpost base: 230 to 240. Unused: 230,231,232,233,237 (11/12/13/18/26)
				#endif
				sk2[0]+=knight_outpost_value_m[bit]; // base bonus
				UINT64 bb3=(bishop_color_masks[0]&bb_2)==0?bishop_color_masks[1]:bishop_color_masks[0];// count bishop of wrong color as absent
				if( !(b->piececolorBB[1][1]|(b->piececolorBB[2][1]&bb3)) ){// add some value if opp has no minor pieces to trade
					#if TRAIN
					pawn_deriv_coeffs[230+11+bishop_outpost_cell[bit]]++;
					#endif
					sk2[0]+=knight_outpost_value2_m[bit];// opp piece bonus
				}
			}
			if( b->piece[bit+1]==128+1 ){// N is blocking opp pawn, not attacked, on 22 central squares
				#if TRAIN
				pawn_deriv_coeffs[230]++;// knight outpost bonus for block
				#endif
				sk2[0]+=knight_outpost_value_m[11]; // extra bonus if N blocks pawn of the opponent
			}else if( b->piece[bit+1]==64+1 ){// N is behind my pawn, not attacked, on 22 central squares
				#if TRAIN
				pawn_deriv_coeffs[231]++;// knight outpost bonus for N is behind my pawn
				#endif
				sk2[0]+=knight_outpost_value_m[12]; // N is behind my pawn
			}
		}// end of N outpost
	}
	bb=b->piececolorBB[1][1];
	while( bb ){// loop over black knights
		GET_BIT(bb)

		// N opp B patterns
		bb_2=b->piececolorBB[2][0];
		while( bb_2 ){// loop over white bishops
			GET_BIT2(bb_2)
			unsigned int index;
			if( bit<32 ) index=flips[bit][1]+flips[bit2][1]*32;// w-b only
			else index=flips[bit][3]+flips[bit2][3]*32;// w-b and l-r
			((int*)sk2)[0]-=((int*)&adj[O_NB+index*2])[0];
		}

		#if calc_pst==1
		((int*)sk2)[0]+=((int*)&piece_square[1][1][bit][0])[0];// black N PST
		#endif
		attack_mask=knight_masks[bit];
		attacks[0][1]|=attack_mask;
		d=(unsigned int)popcnt64l(attack_mask&~(attacks[1][0]|b->colorBB[1])); // exclude occupied/attacked cells
		if( ET1==Full ) king_attack_units[0]+=2*(unsigned int)popcnt64l(attack_mask&km[0]);// white king attack units - 2 for knights
		total_piece_value[1]+=3;
		((int*)sk2)[0]-=((int*)&adj[O_N_MOB+d*2])[0];
		//((int*)sk2)[0]-=((int*)&adj[O_N_MOB2+2*(d*32+flips[bit][1+((bit>>4)&2)])])[0]; // mob2
		#if TRAIN
		pawn_deriv_coeffs[0+d]--;// knight mob
		#endif

		// check for black N outpost: 12 cells (was 22)
		if( ((bb_2=(one<<bit))&0x001c3c3c3c3c1c00) && !(bb_2&attacks[1][0]) ){// not attacked by opp and on 22 cells
			if( (bb_2&0x00001c1c1c1c0000) && (bb_2&attacks[1][1]) && (b->piece[bit-10]!=64+1 || b->piece[bit-9]) && (b->piece[bit+6]!=64+1 || b->piece[bit+7]) ){// in small outpost zone - 12 cells. Protected by a pawn. Not attacked by a pawn, even after 1 move forward
				#if TRAIN
				pawn_deriv_coeffs[230+bishop_outpost_cell[flips[bit][1]]]--;// knight outpost base: 230 to 240. Unused: 230,231,232,233,237
				#endif
				sk2[0]-=knight_outpost_value_m[flips[bit][1]]; // base bonus
				UINT64 bb3=(bishop_color_masks[0]&bb_2)==0?bishop_color_masks[1]:bishop_color_masks[0];// count bishop of wrong color as absent
				if( !(b->piececolorBB[1][0]|(b->piececolorBB[2][0]&bb3)) ){// add some value if opp has no minor pieces to trade
					#if TRAIN
					pawn_deriv_coeffs[230+11+bishop_outpost_cell[flips[bit][1]]]--;
					#endif
					sk2[0]-=knight_outpost_value2_m[flips[bit][1]];// opp bonus piece
				}
			}
			if( b->piece[bit-1]==64+1 ){// N is blocking opp pawn, not attacked, on 22 central squares
				#if TRAIN
				pawn_deriv_coeffs[230]--;// knight outpost bonus for block
				#endif
				sk2[0]-=knight_outpost_value_m[11]; // extra bonus if N blocks pawn of the opponent
			}else if( b->piece[bit-1]==128+1 ){// N is behind my pawn, not attacked, on 22 central squares
				#if TRAIN
				pawn_deriv_coeffs[231]--;// knight outpost bonus for N is behind my pawn
				#endif
				sk2[0]-=knight_outpost_value_m[12]; // N is behind my pawn
			}
		}// end of N outpost
	}

	#if LOG_STEPS
	fprintf(fl,"add knights,%d,%d,%d\n",sk,sk2[0],sk2[1]);
	#endif

	// bishops
	bb=b->piececolorBB[2][0];
	while( bb ){// loop over white bishops
		GET_BIT(bb)
		#if calc_pst==1
		((int*)sk2)[0]+=((int*)&piece_square[2][0][bit][0])[0];// white B PST
		#endif

		// bonus for bishop pinning queen or king: +4 ELO
		bb_2=bishop_masks[bit]&(b->piececolorBB[4][1]|b->piececolorBB[5][1]);
		while( bb_2 ){// bishop attacks something. Check each attacked piece, to see how many pieces block the attack
			GET_BIT2(bb_2)
			if( popcnt64l(ray_segment[bit][bit2]&o)==1 ){// exactly 1 blocker.
				if( bishop_masks[bit]&b->piececolorBB[4][1] ){// queen
					((int*)sk2)[0]+=((int*)&adj[O_B_PIN])[0];
					#if TRAIN
					pawn_deriv_coeffs[184]++;// B pin Q
					#endif
				}else{// king
					((int*)sk2)[0]+=((int*)&adj[O_B_PIN+2])[0];
					#if TRAIN
					pawn_deriv_coeffs[185]++;// B pin K
					#endif
				}
			}
		}

		attack_mask=attacks_bb_B(bit,o);
		attacks[0][0]|=attack_mask;
		d=(unsigned int)popcnt64l(attack_mask&~(attacks[1][1]|b->colorBB[0])); // exclude occupied/attacked cells
		if( ET1==Full ) king_attack_units[1]+=2*(unsigned int)popcnt64l(attack_mask&km[1]);// black king attack units - 2 for bishops
		((int*)sk2)[0]+=((int*)&adj[O_B_MOB+d*2])[0];
		#if TRAIN
		pawn_deriv_coeffs[9+d]++;// bishop mob
		#endif
	}
	bb=b->piececolorBB[2][1];
	while( bb ){// loop over black bishops
		GET_BIT(bb)
		#if calc_pst==1
		((int*)sk2)[0]+=((int*)&piece_square[2][1][bit][0])[0];// black B PST
		#endif

		// bonus for bishop pinning queen or king: +4 ELO
		bb_2=bishop_masks[bit]&(b->piececolorBB[4][0]|b->piececolorBB[5][0]);
		while( bb_2 ){// rook attacks something. Check each attacked piece, to see how many pieces block the attack
			GET_BIT2(bb_2)
			if( popcnt64l(ray_segment[bit][bit2]&o)==1 ){// exactly 1 blocker.
				if( bishop_masks[bit]&b->piececolorBB[4][0] ){// queen
					((int*)sk2)[0]-=((int*)&adj[O_B_PIN])[0];
					#if TRAIN
					pawn_deriv_coeffs[184]--;// B pin Q
					#endif
				}else{// king
					((int*)sk2)[0]-=((int*)&adj[O_B_PIN+2])[0];
					#if TRAIN
					pawn_deriv_coeffs[185]--;// B pin K
					#endif
				}
			}
		}

		attack_mask=attacks_bb_B(bit,o);
		attacks[0][1]|=attack_mask;
		d=(unsigned int)popcnt64l(attack_mask&~(attacks[1][0]|b->colorBB[1])); // exclude occupied/attacked cells
		if( ET1==Full ) king_attack_units[0]+=2*(unsigned int)popcnt64l(attack_mask&km[0]);// white king attack units - 2 for bishops
		total_piece_value[1]+=3;
		((int*)sk2)[0]-=((int*)&adj[O_B_MOB+d*2])[0];
		#if TRAIN
		pawn_deriv_coeffs[9+d]--;// bishop mob
		#endif
	}
	#if LOG_STEPS
	fprintf(fl,"add bishops,%d,%d,%d\n",sk,sk2[0],sk2[1]);
	#endif

	// rooks
	bb=b->piececolorBB[3][0];
	attacks[3][0]=attacks[0][0];attacks[3][1]=attacks[0][1];// store attacks by pawns and minor pieces, to be used in R mob.
	while( bb ){// loop over white rooks
		GET_BIT(bb)
		#if calc_pst==1
		((int*)sk2)[0]+=((int*)&piece_square[3][0][bit][0])[0];// white R PST
		#endif
	
		// bonus for rook pinning queen or king: +1 ELO
		bb_2=rook_masks[bit]&(b->piececolorBB[4][1]|b->piececolorBB[5][1]);
		while( bb_2 ){// rook attacks something. Check each attacked piece, to see how many pieces block the attack
			GET_BIT2(bb_2)
			if( popcnt64l(ray_segment[bit][bit2]&o)==1 ){// exactly 1 blocker.
				if( rook_masks[bit]&b->piececolorBB[4][1] ){// queen
					sk2[0]+=adj[O_R_PIN];
					#if TRAIN
					pawn_deriv_coeffs[88]++;// rook pin Q
					#endif
				}else{// king
					sk2[0]+=adj[O_R_PIN+1];
					#if TRAIN
					pawn_deriv_coeffs[183]++;// rook pin K
					#endif
				}
			}
		}

		attack_mask=attacks_bb_R(bit,o);

		// rook protecting other rook: +4 ELO
		if( attack_mask&bb ){
			((int*)sk2)[0]+=((int*)&adj[O_RPOR])[0];
			#if TRAIN
			pawn_deriv_coeffs[207]++;// rook protecting other rook
			#endif
		}

		attacks[0][0]|=attack_mask;
		d=(unsigned int)popcnt64l(attack_mask&~(attacks[3][1]|b->colorBB[0])); // exclude occupied/attacked cells
		if( ET1==Full ) king_attack_units[1]+=4*(unsigned int)popcnt64l(attack_mask&km[1]);// black king attack units - X for rooks
		((int*)sk2)[0]+=((int*)&adj[O_R_MOB+d*2])[0];
		#if TRAIN
		pawn_deriv_coeffs[23+d]++;// rook mob
		#endif		
	}
	bb=b->piececolorBB[3][1];
	while( bb ){// loop over black rooks
		GET_BIT(bb)
		#if calc_pst==1
		((int*)sk2)[0]+=((int*)&piece_square[3][1][bit][0])[0];// black R PST
		#endif

		// bonus for rook pinning queen or king: +1 ELO
		bb_2=rook_masks[bit]&(b->piececolorBB[4][0]|b->piececolorBB[5][0]);
		while( bb_2 ){// rook attacks something. Check each attacked piece, to see how many pieces block the attack
			GET_BIT2(bb_2)
			if( popcnt64l(ray_segment[bit][bit2]&o)==1 ){// exactly 1 blocker.
				if( rook_masks[bit]&b->piececolorBB[4][0] ){// queen
					sk2[0]-=adj[O_R_PIN];
					#if TRAIN
					pawn_deriv_coeffs[88]--;// rook pin Q
					#endif
				}else{// king
					sk2[0]-=adj[O_R_PIN+1];
					#if TRAIN
					pawn_deriv_coeffs[183]--;// rook pin K
					#endif
				}
			}
		}
		
		attack_mask=attacks_bb_R(bit,o);

		// rook protecting other rook: +4 ELO
		if( attack_mask&bb ){
			((int*)sk2)[0]-=((int*)&adj[O_RPOR])[0];
			#if TRAIN
			pawn_deriv_coeffs[207]--;// rook protecting other rook
			#endif
		}

		attacks[0][1]|=attack_mask;
		d=(unsigned int)popcnt64l(attack_mask&~(attacks[3][0]|b->colorBB[1])); // exclude occupied/attacked cells
		if( ET1==Full) king_attack_units[0]+=4*(unsigned int)popcnt64l(attack_mask&km[0]);// white king attack units - X for rooks
		total_piece_value[1]+=5;
		((int*)sk2)[0]-=((int*)&adj[O_R_MOB+d*2])[0];
		#if TRAIN
		pawn_deriv_coeffs[23+d]--;// rook mob
		#endif
	}
	#if LOG_STEPS
	fprintf(fl,"add rooks,%d,%d,%d\n",sk,sk2[0],sk2[1]);
	#endif

	if( ET1==Full ){
	// queens
	bb=b->piececolorBB[4][0];
	attacks[4][0]=attacks[0][0];attacks[4][1]=attacks[0][1];// store attacks by pawns, minor pieces and rooks, to be used in Q mob.
	while( bb ){// loop over white queens
		GET_BIT(bb)
		#if calc_pst==1
		((int*)sk2)[0]+=((int*)&piece_square[4][0][bit][0])[0];// white Q PST
		#endif

		attack_mask=attacks_bb_B(bit,o)|attacks_bb_R(bit,o);
		
		// here i check if white queen attacks king square which is already attacked by some other piece, and add king safety bonus for it.
		if( b->player==1 && (bb_2=(~b->colorBB[0])&attack_mask&(attacks[0][0]|king_masks[b->kp[0]])&king_masks[b->kp[1]]) ){// exclude occupied by white. Need mask of all attacks except for current one.
			// vary it by whos move it is. And whether the king has escape moves.
			UINT64 al=attacks[0][1];
			if( b->piececolorBB[4][1] ){// add black queens to total attack
				BSF64l(&bit2,b->piececolorBB[4][1]);
				al=attacks[0][1]|attacks_bb_B(bit2,o)|attacks_bb_R(bit2,o);
			}
			if( bb_2&(~al) ) // it is not attacked by opp.
				king_attack_units[1]+=30; // X attack units for safe queen contact
			else
				king_attack_units[1]+=5; // X attack units for safe queen contact
		}
	
		UINT64 aaa=~(king_masks[b->kp[1]]&~attacks[0][0]);// subtract attacks by black king on cells not attacked by white. Need mask of all attacks except for current one.
		aaa&=~(attacks[4][1]|b->colorBB[0]); // exclude occupied/attacked cells. R and lower only.
		if( b->piececolorBB[4][1] ){// there is black queen. Handle it.
			BSF64l(&bit2,b->piececolorBB[4][1]);
			bb_2=attacks_bb_B(bit2,o)|attacks_bb_R(bit2,o);
			bb_2&=~attacks[0][0];
			aaa&=~bb_2;// subtract attacks by black queen on cells not attacked by white.
		}
		d=(unsigned int)popcnt64l(attack_mask&aaa); // exclude occupied/attacked cells
		attacks[0][0]|=attack_mask;// add queens to total attack
		king_attack_units[1]+=3*(unsigned int)popcnt64l(attack_mask&km[1]);// black king attack units - 5 for queens
		((int*)sk2)[0]+=((int*)&adj[O_Q_MOB+d*2])[0];
		#if TRAIN
		pawn_deriv_coeffs[38+d]++;// queen mob
		#endif
	}
	#if LOG_STEPS
	fprintf(fl,"add white queens,%d,%d,%d\n",sk,sk2[0],sk2[1]);
	#endif
	bb=b->piececolorBB[4][1];
	while( bb ){// loop over black queens
		GET_BIT(bb)
		#if calc_pst==1
		((int*)sk2)[0]+=((int*)&piece_square[4][1][bit][0])[0];// black Q PST
		#endif

		attack_mask=attacks_bb_B(bit,o)|attacks_bb_R(bit,o);

		// here i check if black queen attacks king square which is already attacked by some other piece, and add king safety bonus for it.
		if( b->player==2 && (bb_2=(~b->colorBB[1])&attack_mask&(attacks[0][1]|king_masks[b->kp[1]])&king_masks[b->kp[0]]) ){// exclude occupied by black. Need mask of all attacks except for current one.
			// vary it by whos move it is. And whether the king has escape moves.
			// add white queens to total attack: not needed - it was already added when wQ was processed!
			if( bb_2&(~attacks[0][0]) ) // it is not attacked by opp.
				king_attack_units[0]+=30; // X attack units for safe queen contact
			else
				king_attack_units[0]+=5; // X attack units for safe queen contact
		}

		UINT64 aaa=~(king_masks[b->kp[0]]&~attacks[0][1]);// subtract attacks by white king on cells not attacked by black. Need mask of all attacks except for current one.
		aaa&=~(attacks[4][0]|b->colorBB[1]); // exclude occupied/attacked cells. R and lower only.
		if( b->piececolorBB[4][0] ){// there is white queen. Handle it.
			BSF64l(&bit2,b->piececolorBB[4][0]);
			bb_2=attacks_bb_B(bit2,o)|attacks_bb_R(bit2,o);
			bb_2&=~attacks[0][1];
			aaa&=~bb_2;// subtract attacks by white queen on cells not attacked by black.
		}
		d=(unsigned int)popcnt64l(attack_mask&aaa); // exclude occupied/attacked cells
		attacks[0][1]|=attack_mask;// add queens to total attack
		king_attack_units[0]+=3*(unsigned int)popcnt64l(attack_mask&km[0]);// white king attack units - 5 for queens
		total_piece_value[1]+=10;
		((int*)sk2)[0]-=((int*)&adj[O_Q_MOB+d*2])[0];
		#if TRAIN
		pawn_deriv_coeffs[38+d]--;// queen mob
		#endif
	}
	#if LOG_STEPS
	fprintf(fl,"add all queens,%d,%d,%d\n",sk,sk2[0],sk2[1]);
	#endif
	}

	// now turn king attack units into king safety score
	total_piece_value[0]=b->piece_value-total_piece_value[1];// define

	if( ET1==Full ){
	if( total_piece_value[1]>=13 && b->piececolorBB[4][1] ){// only if queen and at least one piece
		if( (b->kp[0]&7)<=1 ){// only look at pawn shield if king is close to base (0 or 1)
			king_attack_units[0]+=(unsigned int)popcnt64l(attacks[1][1]&km[0]);// add 1 atack unit per pawn attack on king vicinity		
			km[0]=king_masks[b->kp[0]]|(one<<b->kp[0]);
			km[0]=((km[0]<<1)|km[0])&(~(km[0]>>1));// 2 rows in front of the king only
			king_attack_units[0]+=max(0,2-(int)popcnt64l(b->piececolorBB[0][0]&km[0]));// plus one attack unit for missing pawn shield
		}
		king_attack_units[0]+=base_king_attacks[b->kp[0]];

		// king mob, endgame only
		d=(unsigned int)popcnt64l((~(attacks[0][1]|king_masks[b->kp[1]]))&king_masks[b->kp[0]]);// number of king moves. 0 to 8 (9)
		if( d<4 ) sk2[1]-=adj[O_K_MOB+d];
		#if LOG_STEPS
		fprintf(fl,"w king mob,%d,%d,%d,%d,%d\n",sk,sk2[0],sk2[1],d,adj[O_K_MOB+d]);
		#endif
		#if TRAIN
		if(d<4) pawn_deriv_coeffs[203+d]--;// 203-206.
		#endif

		int d2=adj[O_K_SAFETY+min(king_attack_units[0],61)];
		d2=(d2*KSscale[total_piece_value[1]])>>5;// scale with attacker material
		sk-=d2; // here applying it to midgame only is a wash
		#if TRAIN
		ka[0]=min(king_attack_units[0],61);
		pawn_deriv_coeffs[99+min(king_attack_units[0],61)]-=KSscale[total_piece_value[1]];// king safety 62
		#endif		
	}
	#if LOG_STEPS
	fprintf(fl,"add king attack scores - white,%d,%d,%d\n",sk,sk2[0],sk2[1]);
	#endif
	if( total_piece_value[0]>=13 && b->piececolorBB[4][0] ){// only if queen and at least one piece
		if( (b->kp[1]&7)>=6 ){// only look at pawn shield if king is close to base (7 or 6)
			king_attack_units[1]+=(unsigned int)popcnt64l(attacks[1][0]&km[1]);// add 1 atack unit per pawn attack on king vicinity		
			km[1]=king_masks[b->kp[1]]|(one<<b->kp[1]);
			km[1]=((km[1]>>1)|km[1])&(~(km[1]<<1));// 2 rows in front of the king only
			king_attack_units[1]+=max(0,2-(int)popcnt64l(b->piececolorBB[0][1]&km[1]));// plus one attack unit for missing pawn shield
		}
		king_attack_units[1]+=base_king_attacks[flips[b->kp[1]][1]];

		// king mob, endgame only
		d=(unsigned int)popcnt64l((~(attacks[0][0]|king_masks[b->kp[0]]))&king_masks[b->kp[1]]);// number of king moves
		if( d<4 ) sk2[1]+=adj[O_K_MOB+d];
		#if LOG_STEPS
		fprintf(fl,"b king mob,%d,%d,%d,%d,%d\n",sk,sk2[0],sk2[1],d,adj[O_K_MOB+d]);
		#endif
		#if TRAIN
		if( d<4 ) pawn_deriv_coeffs[203+d]++;// 203-206.
		#endif

		int d2=adj[O_K_SAFETY+min(king_attack_units[1],61)];
		d2=(d2*KSscale[total_piece_value[0]])>>5;// scale with attacker material
		sk+=d2; // here applying it to midgame only is a wash
		#if TRAIN
		ka[1]=min(king_attack_units[1],61);
		pawn_deriv_coeffs[99 + min(king_attack_units[1], 61)] += KSscale[total_piece_value[0]];// king safety 62
		#endif
	}
	}

	#if LOG_STEPS
	fprintf(fl,"add king attack scores - black,%d,%d,%d\n",sk,sk2[0],sk2[1]);
	#endif
	

	// bonus for unstoppable passed pawn(s). Only if opp has no more than 1 piece (excluding Q).
	// white
	int unstoppable_pawn_dist[2]={99,99};// init to a lot
	if( total_piece_value[1]<=5 && b->piececolorBB[0][0] ){// black has no pieces other than lone NBR, only king (and pawns)
		bb=b->piececolorBB[0][0]; // white pawns
		UINT64 b_bb=flip_color(b->piececolorBB[0][1]);// black pawns, flipped so that they are from point of view of black
		do{// loop over white pawns
			GET_BIT(bb)
			UINT64 pm1;// passed mask. If my move and next cell is empty, assume i just moved forward
			int d0,d0a,bit1;
			if( b->player==1 && b->piece[bit+1]==0 ){
				pm1=passed_mask[bit+1];
				d0a=-1;
				bit1=bit+1; // move it forward
			}else{
				pm1=passed_mask[bit];
				d0a=0;
				bit1=bit;
			}
			if( !(b_bb&pm1) && !(b->piececolorBB[0][0]&blocked_mask[bit]) ){ // passed pawn, not blocked by my other pawns.
				d0=7-(bit&7);// dist to promotion square
				d0a+=d0;// dist to promotion square after i move my pawn forward, and it is opp turn

				if( total_piece_value[1] && d0a>1 )// skip if opp piece(s) and more than 1 my move (after initial move)
					continue;
				int ps=bit+d0;// promotion square

				// 4. add king distance bonus/penalty, for both kings. Only if not unstoppable.
				int y,x=min(dist[b->kp[0]][bit]-1,3)*4+min(dist[b->kp[1]][bit]-1,3);// 0 to 3*4+3=15.
				if( total_piece_value[1] ){
					y=adj[O_K_PP1+x];
					x+=25;
				}else
					y=adj[O_K_PP0+x];
				sk+=y;
				#if TRAIN
				pawn_deriv_coeffs[161+x]++;
				#endif

				// 3a. check if opp bishop cannot get to it
				if( b->piececolorBB[2][1] ){// opp bishop
					if( d0a==0 ){// my pawn moves to promotion square immediately. Can bishop attack it?
						if( b->piece[ps] || (attacks_bb_B(ps,o)&b->piececolorBB[2][1]) )// yes, it can. Or ps is occupied. Skip this pawn.
							continue;
					}else{
					UINT64 b1=(bishop_color_masks[0]&b->piececolorBB[2][1])==0?bishop_color_masks[1]:bishop_color_masks[0];// opp bishop
					BSF64l(&bit2,b->piececolorBB[2][1]);// now bit2 is bishop's position
					if( !(b1&(one<<ps)) ){// bishop is on color opposite of stop square - it can attack rank 7
						// is bishop attacking rank 7 cell right now?
						if( (dir_norm[ps-1][bit2]==7 || dir_norm[ps-1][bit2]==9) && !(ray_segment[ps-1][bit2]&o) )// on a DIAGONAL line, nothing in between - attack.
							if( !(attacks[1][0]&(one<<(ps-1))) )// but only if it is not protected by another pawn. This works, but rarely.
								continue;
					}else{// bishop is able to attack stop square
						// does bishop have a move to the cell(s) attacking stop square? There could be 2 such cells.
						// get bishop move mask
						attack_mask=attacks_bb_B(bit2,o);// from bit2
						attack_mask&=~b->colorBB[1];// eliminate cells occupied by black
						attack_mask|=one<<bit2; // add current cell, to capture situations where bishop already attacks the stop square, and is next to it.
						// get mask of bishop attacks from stop square
						UINT64 attack_mask2=attacks_bb_B(ps,o);// from stop square
						attack_mask2&=~b->colorBB[1];// eliminate cells occupied by black
						attack_mask2|=one<<ps; // add current cell
						// do the masks intersect? If they do, ps is attackable.
						if( attack_mask&attack_mask2 )
							if( !(attacks[1][0]&(one<<ps)) )// but only if it is not protected by another pawn. This works, but rarely.
								continue;
					}
					}
				}

				// 3b. check if opp knight cannot get to it
				if( b->piececolorBB[1][1] ){// opp knight
					if( d0a==0 ){// my pawn moves to promotion square immediately. Can knight attack it?
						if( b->piece[ps] || (knight_masks[ps]&b->piececolorBB[1][1]) )// yes, it can. Or ps is occupied. Skip this pawn.
							continue;
					}else{
					BSF64l(&bit2,b->piececolorBB[1][1]);// now bit2 is knight's position
					// is knight attacking ps-1?
					if( knight_masks[bit2]&(one<<(ps-1)) )
						if( !(attacks[1][0]&(one<<(ps-1))) )// but only if it is not protected by another pawn. This works, but rarely.
							continue;
					// can knight attack ps after 1 move (excluding moves to opp occupied cells)? Or is it attacking it now?
					if( knight_masks[bit2]&(one<<ps) || knight_masks[bit2]&knight_masks[ps]&(~b->colorBB[1]) )
						if( !(attacks[1][0]&(one<<ps)) )// but only if it is not protected by another pawn. This works, but rarely.
							continue;
					}
				}

				// 3c. check if opp rook cannot get to it
				if( b->piececolorBB[3][1] ){// opp rook
					if( d0a==0 ){// my pawn moves to promotion square immediately. Can rook attack it?
						if( b->piece[ps] || (attacks_bb_R(ps,o&(~(one<<(ps-1))))&b->piececolorBB[3][1]) )// yes, it can. Or ps is occupied. Skip this pawn.
							continue;
					}else{
						// new logic: 2 connected passed pawns are good agains rook no matter what. As long as opp king is far. And second pawn is passed. Use bit and bit1
						if( (bit>8 && b->piece[bit-9]==65 && b->piece[bit-8]==0 && (bit<16 || b->piece[bit-16]==0) && dist[ps-1][b->kp[1]]>2 && dist[ps-8][b->kp[1]]>2)
							|| (bit<56 && b->piece[bit+7]==65 && b->piece[bit+8]==0 && (bit>48 || b->piece[bit+16]==0) && dist[ps-1][b->kp[1]]>2 && dist[ps+8][b->kp[1]]>2)
							|| (bit>8 && b->piece[bit1-9]==65 && b->piece[bit1-8]==0 && (bit<16 || b->piece[bit1-16]==0) && dist[ps-1][b->kp[1]]>2 && dist[ps-8][b->kp[1]]>2)
							|| (bit<56 && b->piece[bit1+7]==65 && b->piece[bit1+8]==0 && (bit>48 || b->piece[bit1+16]==0) && dist[ps-1][b->kp[1]]>2 && dist[ps+8][b->kp[1]]>2)
						){ // friendly pawn on left/right, free to move, not attacked, opp king is far
							unstoppable_pawn_dist[0]=min(unstoppable_pawn_dist[0],d0+1); // add 1 move for supporting pawn. Do i really need this here?
							sk-=y;
							#if TRAIN
							pawn_deriv_coeffs[161+x]--;
							#endif
							continue;
						}
						BSF64l(&bit2,b->piececolorBB[3][1]);// now bit2 is rook's position
						// is rook attacking ps-1 now?
						attack_mask=attacks_bb_R(bit2,o);// from bit2
						if( attack_mask&(one<<(ps-1)) )// it is - skip this.
							if( !(attacks[1][0]&(one<<(ps-1))) )// but only if it is not protected by another pawn. This works, but rarely.
								continue;
						// is rook attacking ps now?
						if( attack_mask&(one<<ps) )
							if( !(attacks[1][0]&(one<<ps)) )// but only if it is not protected by another pawn. Or king, but not both kings
								if( dist[ps][b->kp[0]]>1 || (dist[ps][b->kp[0]]==1 && dist[ps][b->kp[1]]<=2) )// but only if it is not protected by king, but not both kings
									continue;
						// can rook attack ps after 1 move (excluding moves to opp occupied cells)? Or is it attacking it now?
						UINT64 attack_mask2=attacks_bb_R(ps,o);// from stop square
						if( attack_mask&attack_mask2&(~b->colorBB[1]) )// do the masks intersect? If they do, ps is attackable. Eliminate cells occupied by black
							if( !(attacks[1][0]&(one<<ps)) )// but only if it is not protected by another pawn. This works, but rarely.
								if( dist[ps][b->kp[0]]>1 || (dist[ps][b->kp[0]]==1 && dist[ps][b->kp[1]]==1) )// but only if it is not protected by king, but not both kings
									continue;
					}
				}

				// 1a. check if it is unstoppable=opp king is too far away from it
				int d1=0;// my turn or opp turn (0/1)?
				if( b->player==2 )// increment distance if opp's turn
					d1=1;
				d0+=(int)popcnt64l(b->colorBB[0]&blocked_mask[bit]);// add to distance count of friendly non-pawn blockers (all pawn blockers have already been excluded)
				if( dist[ps][b->kp[1]]>d0+d1 ){
					unstoppable_pawn_dist[0]=min(unstoppable_pawn_dist[0],d0);
					sk-=y;
					#if TRAIN
					pawn_deriv_coeffs[161+x]--;
					#endif
					continue;
				}

				// 1b. opp king is closer, but his path is blocked
				if( (b->kp[1]&7)==7 && dist[ps][b->kp[1]]==d0+d1 ){// same distance, opp king on rank 8 only.
					int blocker;
					if( (b->kp[1]>>3)<(ps>>3) )// opp king on lower file
						blocker=ps-9;
					else// opp king on higher file
						blocker=ps+7;
					if( b->piece[blocker] ){// opp king path is blocked!
						unstoppable_pawn_dist[0]=min(unstoppable_pawn_dist[0],d0);
						sk-=y;
						#if TRAIN
						pawn_deriv_coeffs[161+x]--;
						#endif
						continue;
					}
				}

				// 2a. check if friendly king fully protects my promotion path
				if( dist[b->kp[0]][ps]==1 && dist[b->kp[0]][bit]==1 && ( (bit&56)!=(b->kp[0]&56) || (bit>7 && bit<56) ) ){// king protects both pawn and promotion square, and is either not blocking or on file other than A or H
					unstoppable_pawn_dist[0]=min(unstoppable_pawn_dist[0],d0);
					sk-=y;
					#if TRAIN
					pawn_deriv_coeffs[161+x]--;
					#endif
					continue;
				}

				// 2b. check if friendly king is closer to pawn and to promotion square than opp king. This always makes the pawn unstoppable (I think).
				if( dist[b->kp[0]][ps]+d1<dist[b->kp[1]][ps] && dist[b->kp[0]][bit]+d1<dist[b->kp[1]][bit] ){
					unstoppable_pawn_dist[0]=min(unstoppable_pawn_dist[0],d0);
					sk-=y;
					#if TRAIN
					pawn_deriv_coeffs[161+x]--;
					#endif
					continue;
				}
			}
		}while( bb );
	}
	// black
	if( total_piece_value[0]<=5 && b->piececolorBB[0][1] ){// white has no pieces, other than lone NBR, only king (and pawns)
		bb=flip_color(b->piececolorBB[0][1]);// black pawns, flipped so that they are from point of view of black
		UINT64 bb0=bb;
		UINT64 w_bb=b->piececolorBB[0][0];// white pawns
		do{// loop over black pawns
			GET_BIT(bb)
			UINT64 pm1;// passed mask. If my move and next cell is empty, assume i just moved forward
			int d0,d0a,bit1;
			if( b->player==2 && b->piece[flips[bit][1]-1]==0 ){
				pm1=passed_mask[bit+1];
				d0a=-1;
				bit1=bit+1; // move it forward
			}else{
				pm1=passed_mask[bit];
				d0a=0;
				bit1=bit;
			}
			if( !(w_bb&pm1) && !(bb0&blocked_mask[bit]) ){ // passed pawn, not blocked by my other pawns.
				d0=7-(bit&7);// dist to promotion square
				d0a+=d0;// dist to promotion square after i move my pawn forward, and it is opp turn

				if( total_piece_value[0] && d0a>1 )// skip if opp piece(s) and more than 1 my move (after initial move)
					continue;
				int ps=bit&56;// promotion square. Real one

				// 4. add king distance bonus/penalty, for both kings. Only if not unstoppable.
				int y,x=min(dist[b->kp[1]][flips[bit][1]]-1,3)*4+min(dist[b->kp[0]][flips[bit][1]]-1,3);// 0 to 3*4+3=15.
				if( total_piece_value[0] ){
					y=adj[O_K_PP1+x];
					x+=25;
				}else
					y=adj[O_K_PP0+x];
				sk-=y;
				#if TRAIN
				pawn_deriv_coeffs[161+x]--;
				#endif

				// 3a. check if opp bishop cannot get to it
				if( b->piececolorBB[2][0] ){// opp bishop
					if( d0a==0 ){// my pawn moves to promotion square immediately. Can bishop attack it?
						if( b->piece[ps] || (attacks_bb_B(ps,o)&b->piececolorBB[2][0]) )// yes, it can. Or ps is occupied. Skip this pawn.
							continue;
					}else{
					UINT64 b1=(bishop_color_masks[0]&b->piececolorBB[2][0])==0?bishop_color_masks[1]:bishop_color_masks[0];// opp bishop
					BSF64l(&bit2,b->piececolorBB[2][0]);// now bit2 is bishop's position
					if( !(b1&(one<<ps)) ){// bishop is on color opposite of stop square - attack rank 7
						// is bishop attacking rank 7 cell right now?
						if( (dir_norm[ps+1][bit2]==7 || dir_norm[ps+1][bit2]==9) && !(ray_segment[ps+1][bit2]&o) )// on a DIAGONAL line, nothing in between - attack.
							if( !(attacks[1][1]&(one<<(ps+1))) )// but only if it is not protected by another pawn. This works, but rarely.
								continue;
					}else{// bishop is able to attack stop square
						// does bishop have a move to the cell(s) attacking stop square? There could be 2 such cells.
						// get bishop move mask
						attack_mask=attacks_bb_B(bit2,o);// from bit2
						attack_mask&=~b->colorBB[0];// eliminate cells occupied by player (keep opponent - those are attacks)
						attack_mask|=one<<bit2; // add current cell, to capture situations where bishop already attacks the stop square, and is next to it.
						// get mask of bishop attacks from stop square
						UINT64 attack_mask2=attacks_bb_B(ps,o);// from stop square
						attack_mask2&=~b->colorBB[0];// eliminate cells occupied by player (keep opponent - those are attacks)
						attack_mask2|=one<<ps; // add current cell
						// do the masks intersect? If they do, next pawn cell is attackable.
						if( attack_mask&attack_mask2 )
							if( !(attacks[1][1]&(one<<ps)) )// but only if it is not protected by another pawn. This works, but rarely.
								continue;
					}
					}
				}

				// 3b. check if opp knight cannot get to it
				if( b->piececolorBB[1][0] ){// opp knight
					if( d0a==0 ){// my pawn moves to promotion square immediately. Can knight attack it?
						if( b->piece[ps] || (knight_masks[ps]&b->piececolorBB[1][0]) )// yes, it can. Or ps is occupied. Skip this pawn.
							continue;
					}else{
					BSF64l(&bit2,b->piececolorBB[1][0]);// now bit2 is knight's position
					// is knight attacking ps+1?
					if( knight_masks[bit2]&(one<<(ps+1)) )
						if( !(attacks[1][1]&(one<<(ps+1))) )// but only if it is not protected by another pawn. This works, but rarely.
							continue;
					// can knight attack ps after 1 move (excluding moves to opp occupied cells)? Or is it attacking it now?
					if( knight_masks[bit2]&(one<<ps) || knight_masks[bit2]&knight_masks[ps]&(~b->colorBB[0]) )
						if( !(attacks[1][1]&(one<<ps)) )// but only if it is not protected by another pawn. This works, but rarely.
							continue;
					}
				}

				// 3c. check if opp rook cannot get to it
				if( b->piececolorBB[3][0] ){// opp rook
					if( d0a==0 ){// my pawn moves to promotion square immediately. Can rook attack it?
						if( b->piece[ps] || (attacks_bb_R(ps,o&(~(one<<(ps+1))))&b->piececolorBB[3][0]) )// yes, it can. Or ps is occupied. Skip this pawn.
							continue;
					}else{
						// new logic: 2 connected passed pawns are good agains rook no matter what. As long as opp king is far. And second pawn is passed. Use bit and bit1 - position after move forward.
						unsigned int fb=flips[bit][1];
						unsigned int fb1=flips[bit1][1];
						if( (bit>8 && b->piece[fb-7]==129 && b->piece[fb-8]==0 && (bit<16 || b->piece[fb-16]==0) && dist[ps+1][b->kp[0]]>2 && dist[ps-8][b->kp[0]]>2)
							|| (bit<56 && b->piece[fb+9]==129 && b->piece[fb+8]==0 && (bit>48 || b->piece[fb+16]==0) && dist[ps+1][b->kp[0]]>2 && dist[ps+8][b->kp[0]]>2)
							|| (bit>8 && b->piece[fb1-7]==129 && b->piece[fb1-8]==0 && (bit<16 || b->piece[fb1-16]==0) && dist[ps+1][b->kp[0]]>2 && dist[ps-8][b->kp[0]]>2)
							|| (bit<56 && b->piece[fb1+9]==129 && b->piece[fb1+8]==0 && (bit>48 || b->piece[fb1+16]==0) && dist[ps+1][b->kp[0]]>2 && dist[ps+8][b->kp[0]]>2)
						){ // friendly pawn on left/right, free to move, not attacked, opp king is far
							unstoppable_pawn_dist[1]=min(unstoppable_pawn_dist[1],d0+1); // add 1 move for supporting pawn. Do i really need this here?
							sk+=y;
							#if TRAIN
							pawn_deriv_coeffs[161+x]++;
							#endif
							continue;
						}
						BSF64l(&bit2,b->piececolorBB[3][0]);// now bit2 is rook's position
						// is rook attacking ps+1 now?
						attack_mask=attacks_bb_R(bit2,o);// from bit2
						if( attack_mask&(one<<(ps+1)) )// it is - skip this.
							if( !(attacks[1][1]&(one<<(ps+1))) )// but only if it is not protected by another pawn. This works, but rarely.
								continue;
						// is rook attacking ps now?
						if( attack_mask&(one<<ps) )// is rook attacking ps now?
							if( !(attacks[1][1]&(one<<ps)) )// but only if it is not protected by another pawn. Or king, but not both kings
								if( dist[ps][b->kp[1]]>1 || (dist[ps][b->kp[1]]==1 && dist[ps][b->kp[0]]<=2) )// but only if it is not protected by king, but not both kings
									continue;
						// can rook attack ps after 1 move (excluding moves to opp occupied cells)? 
						UINT64 attack_mask2=attacks_bb_R(ps,o);// from stop square
						if( attack_mask&attack_mask2&(~b->colorBB[0]) )// do the masks intersect? If they do, ps is attackable. eliminate cells occupied by white
							if( !(attacks[1][1]&(one<<ps)) )// but only if it is not protected by another pawn. This works, but rarely.
								if( dist[ps][b->kp[1]]>1 || (dist[ps][b->kp[1]]==1 && dist[ps][b->kp[0]]==1) )// but only if it is not protected by king, but not both kings
									continue;
					}
				}

				// 1a. check if it is unstoppable=opp king is too far away from it
				int d1=0;
				if( b->player==1 )// increment distance if opp's turn
					d1=1;
				d0+=(int)popcnt64l(flip_color(b->colorBB[1])&blocked_mask[bit]);// add to distance count of friendly non-pawn blockers (all pawn blockers have already been excluded)
				if( dist[ps][b->kp[0]]>d0+d1 ){
					unstoppable_pawn_dist[1]=min(unstoppable_pawn_dist[1],d0);
					sk+=y;
					#if TRAIN
					pawn_deriv_coeffs[161+x]++;
					#endif
					continue;
				}

				// 1b. opp king is closer, but his path is blocked
				if( (b->kp[0]&7)==0 && dist[ps][b->kp[0]]==d0+d1 ){// same distance, opp king on rank 1 only.
					int blocker;
					if( (b->kp[0]>>3)<(ps>>3) )// opp king on lower file
						blocker=ps-7;
					else// opp king on higher file
						blocker=ps+9;
					if( b->piece[blocker] ){// opp king path is blocked!
						unstoppable_pawn_dist[1]=min(unstoppable_pawn_dist[1],d0);
						sk+=y;
						#if TRAIN
						pawn_deriv_coeffs[161+x]++;
						#endif
						continue;
					}
				}

				// 2a. check if friendly king fully protects my promotion path
				bit=flips[bit][1];// flip it, so that from now on it is "normal"****************************
				if( dist[b->kp[1]][ps]==1 && dist[b->kp[1]][bit]==1 && ( (bit&56)!=(b->kp[1]&56) || (bit>7 && bit<56) ) ){// king protects both pawn and promotion square, and is either not blocking or on file other than A or H
					unstoppable_pawn_dist[1]=min(unstoppable_pawn_dist[1],d0);
					sk+=y;
					#if TRAIN
					pawn_deriv_coeffs[161+x]++;
					#endif
					continue;
				}

				// 2b. check if friendly king is closer to pawn and to promotion square than opp king. This always makes the pawn unstoppable (I think).
				if( dist[b->kp[1]][ps]+d1<dist[b->kp[0]][ps] && dist[b->kp[1]][bit]+d1<dist[b->kp[0]][bit] ){
					unstoppable_pawn_dist[1]=min(unstoppable_pawn_dist[1],d0);
					sk+=y;
					#if TRAIN
					pawn_deriv_coeffs[161+x]++;
					#endif
					continue;
				}
			}
		}while( bb );
	}

	#if LOG_STEPS
	fprintf(fl,"add endgame king distances,%d,%d,%d\n",sk,sk2[0],sk2[1]);
	#endif

	// compare min promotion distances of the players: adds less than 10 ELO.
	if( unstoppable_pawn_dist[0]+unstoppable_pawn_dist[1]<99*2 ){// something is unstoppable - look into it.
		// here values are true distances for pawns to move, regardles of turn.
		int dw=unstoppable_pawn_dist[0]*2-(b->player==1);// half-moves for white promotion, from now.
		int db=unstoppable_pawn_dist[1]*2-(b->player==2);// half-moves for black promotion, from now.

		// at least 1 half-move between promotions
		if( dw<db-1 ){
			sk+=adj[O_UPP];
			#if TRAIN
			pawn_deriv_coeffs[177]++;// unstoppable passed pawn
			#endif
		}else if( db<dw-1 ){
			sk-=adj[O_UPP];
			#if TRAIN
			pawn_deriv_coeffs[177]--;// unstoppable passed pawn
			#endif
		}
		//else diff is 0 or 1 - do not adjust the score
	}

	#if LOG_STEPS
	fprintf(fl,"add unstoppable passed pawns,%d,%d,%d\n",sk,sk2[0],sk2[1]);
	#endif

	// get pawn scores
	// exclude if train and use_hash=0. Need to ewclude this so that pawn deriv coeffs are not overwritten!
	#if TRAIN
	if( use_hash==1 ){
	#endif
	((int*)sk2)[0]+=pawn_score(b);
	#if TRAIN
	}
	#endif
	
	#if LOG_STEPS
	fprintf(fl,"add pawns,%d,%d,%d\n",sk,sk2[0],sk2[1]);
	#endif

	// combine m and e scores
	if( b->player==2 ){// change sign for black for all "sk" vars
		((int*)sk2)[0]=-((int*)sk2)[0];
		sk=-sk;
	}
	#if calc_pst==1
	#else
	((int*)sk2)[0]+=((int*)&b->scorem)[0];
	#endif
	
	#if LOG_STEPS
	if( b->player==1 ) fprintf(fl,"add PST,%d,%d,%d\n",sk,sk2[0],sk2[1]);
	else fprintf(fl,"add PST,%d,%d,%d\n",-sk,-sk2[0],-sk2[1]);
	#endif

	sk+=sk2[0]+(((sk2[1]-sk2[0])*endgame_weight_all_i[b->piece_value])>>10); // blend

	// apply multiple
	//sk=(sk*(1024+mh2[b->mat_key]))/1024;

	// Beal effect
	//sk+=int(b->hash_key&15)-8; // add +-8

	#if LOG_STEPS
	if( b->player==1 ) fprintf(fl,"the end,%d,%d,%d\n",sk,sk2[0],sk2[1]);
	else fprintf(fl,"the end,%d,%d,%d\n",-sk,-sk2[0],-sk2[1]);
	fclose(fl);
	exit(7);
	#endif

	#if TRAIN
	#else
	// add score to eval hash table. Always replace.
	h1d.s=sk;
	((eTT*)h1)[0]=h1d;		// atomic write
	#endif

	return(sk);// return result
}